<!DOCTYPE html><html>
  <head>
    <meta name="darkreader-lock" content="true">
    <link rel="alternate" type="application/rss+xml" title="Koiro's Cat CafÃ©" href="/rss.xml">
    <meta http-equiv="Content-Type" content="charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="/assets/js/header.js"></script>
    <script src="/assets/katex/katex.js"></script>
<script defer src="/assets/katex/auto-render.min.js" onload="renderMathInElement(document.body);"></script>    <script>document.addEventListener(&quot;DOMContentLoaded&quot;, function() {
    renderMathInElement(document.body, {
      delimiters: [
          {left: '$$', right: '$$', display: false},
      ],
      throwOnError : false
    });
});</script>
    <link rel="stylesheet" href="/assets/katex/katex.css">
    <link rel="stylesheet" href="/assets/css/reset.css">
    <link rel="stylesheet" href="/assets/css/root.css">
    <link rel="stylesheet" href="/assets/css/color_scheme_v2.dark_mode.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@300;400;600;700&amp;display=swap" rel="stylesheet">
    <script src="/assets/js/highlightjs/highlight.js"></script>
    <link rel="stylesheet" href="/assets/css/layout.css">
    <link rel="stylesheet" href="/assets/css/page_content.css">
    <link rel="stylesheet" href="/assets/css/post.css">
    <link rel="stylesheet" href="/assets/css/color_scheme_v2.dark_mode.css">
    <link rel="stylesheet" href="/assets/css/highlightjs/github-dark.css">
    <title>ğŸš¯ Unreal 5 åƒåœ¾å›æ”¶æºç æ¢³ç†</title>
  </head>
  <body>
    <script>hljs.highlightAll();</script>
    <div class="post">
      <div class="sidebar_wrapper_left sidebar_wrapper">
        <div class="navi"><a class="navi_link button" href="/home.html"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" fill="none" version="1.1" width="21" height="20.999996185302734" viewBox="0 0 21 20.999996185302734"><defs><clipPath id="master_svg0_9_0235"><rect x="0" y="0" width="21" height="20.999996185302734" rx="0"/></clipPath></defs><g clip-path="url(#master_svg0_9_0235)"><g><path d="M9.9628,1.059317C10.27877,0.8135611,10.7212,0.8135611,11.03716,1.059317C11.03716,1.059317,18.9122,7.18432,18.9122,7.18432C19.1253,7.35009,19.25,7.60498,19.25,7.875C19.25,7.875,19.25,17.5,19.25,17.5C19.25,18.1962,18.9734,18.8639,18.4811,19.3561C17.9889,19.8484,17.321199999999997,20.125,16.625,20.125C16.625,20.125,4.375,20.125,4.375,20.125C3.67881,20.125,3.01113,19.8484,2.518845,19.3561C2.026561,18.8639,1.75,18.1962,1.75,17.5C1.75,17.5,1.75,7.875,1.75,7.875C1.75,7.60498,1.874664,7.35009,2.087802,7.18432C2.087802,7.18432,9.9628,1.059317,9.9628,1.059317C9.9628,1.059317,9.9628,1.059317,9.9628,1.059317ZM8.75,18.375C8.75,18.375,12.25,18.375,12.25,18.375C12.25,18.375,12.25,11.375,12.25,11.375C12.25,11.375,8.75,11.375,8.75,11.375C8.75,11.375,8.75,18.375,8.75,18.375C8.75,18.375,8.75,18.375,8.75,18.375ZM14,18.375C14,18.375,14,10.5,14,10.5C14,10.01674,13.6083,9.625,13.125,9.625C13.125,9.625,7.875,9.625,7.875,9.625C7.39176,9.625,7,10.01674,7,10.5C7,10.5,7,18.375,7,18.375C7,18.375,4.375,18.375,4.375,18.375C4.14293,18.375,3.92038,18.2828,3.75628,18.1187C3.59219,17.9547,3.5,17.732,3.5,17.5C3.5,17.5,3.5,8.30295,3.5,8.30295C3.5,8.30295,10.5,2.8585000000000003,10.5,2.8585000000000003C10.5,2.8585000000000003,17.5,8.30295,17.5,8.30295C17.5,8.30295,17.5,17.5,17.5,17.5C17.5,17.732,17.4078,17.9547,17.2437,18.1187C17.0796,18.2828,16.857,18.375,16.625,18.375C16.625,18.375,14,18.375,14,18.375C14,18.375,14,18.375,14,18.375Z" fill-rule="evenodd" fill="#373737" fill-opacity="1"/></g></g></svg></a><a class="navi_link button" href="/blogs.html"><svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="#434343"><path d="M520-600v-240h320v240H520ZM120-440v-400h320v400H120Zm400 320v-400h320v400H520Zm-400 0v-240h320v240H120Zm80-400h160v-240H200v240Zm400 320h160v-240H600v240Zm0-480h160v-80H600v80ZM200-200h160v-80H200v80Zm160-320Zm240-160Zm0 240ZM360-280Z"/></svg></a><a class="navi_link button" href="/portfolio.html"><svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="#434343"><path d="M619-108q-11 11-25.5 17T563-85q-16 0-31-6t-26-17l-56-56q-11-11-16.5-24.5T427-216q-1-14 3.5-28t13.5-26l6-8-326-466 156-156 509 509q11 11 17 25.5t6 30.5q0 16-6 31t-17 26L619-108ZM507-335l113-112-340-340-52 52 279 400Zm56 170 169-169-56-57-170 170 57 56Zm-56-170 113-112-113 112Z"/></svg></a><a class="navi_link button" href="/about.html"><svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="#434343"><path d="M194-80v-395h80v315h280v-193l105-105q29-29 45-65t16-77q0-40-16.5-76T659-741l-25-26-127 127H347l-43 43-57-56 67-67h160l160-160 82 82q40 40 62 90.5T800-600q0 57-22 107.5T716-402l-82 82v240H194Zm197-187L183-475q-11-11-17-26t-6-31q0-16 6-30.5t17-25.5l84-85 124 123q28 28 43.5 64.5T450-409q0 40-15 76.5T391-267Z"/></svg></a></div>
      </div>
      <div class="contents">
        <div class="top_gap_space"></div>
        <div class="header"><a class="navi_link button" href="/home.html"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" fill="none" version="1.1" width="21" height="20.999996185302734" viewBox="0 0 21 20.999996185302734"><defs><clipPath id="master_svg0_9_0235"><rect x="0" y="0" width="21" height="20.999996185302734" rx="0"/></clipPath></defs><g clip-path="url(#master_svg0_9_0235)"><g><path d="M9.9628,1.059317C10.27877,0.8135611,10.7212,0.8135611,11.03716,1.059317C11.03716,1.059317,18.9122,7.18432,18.9122,7.18432C19.1253,7.35009,19.25,7.60498,19.25,7.875C19.25,7.875,19.25,17.5,19.25,17.5C19.25,18.1962,18.9734,18.8639,18.4811,19.3561C17.9889,19.8484,17.321199999999997,20.125,16.625,20.125C16.625,20.125,4.375,20.125,4.375,20.125C3.67881,20.125,3.01113,19.8484,2.518845,19.3561C2.026561,18.8639,1.75,18.1962,1.75,17.5C1.75,17.5,1.75,7.875,1.75,7.875C1.75,7.60498,1.874664,7.35009,2.087802,7.18432C2.087802,7.18432,9.9628,1.059317,9.9628,1.059317C9.9628,1.059317,9.9628,1.059317,9.9628,1.059317ZM8.75,18.375C8.75,18.375,12.25,18.375,12.25,18.375C12.25,18.375,12.25,11.375,12.25,11.375C12.25,11.375,8.75,11.375,8.75,11.375C8.75,11.375,8.75,18.375,8.75,18.375C8.75,18.375,8.75,18.375,8.75,18.375ZM14,18.375C14,18.375,14,10.5,14,10.5C14,10.01674,13.6083,9.625,13.125,9.625C13.125,9.625,7.875,9.625,7.875,9.625C7.39176,9.625,7,10.01674,7,10.5C7,10.5,7,18.375,7,18.375C7,18.375,4.375,18.375,4.375,18.375C4.14293,18.375,3.92038,18.2828,3.75628,18.1187C3.59219,17.9547,3.5,17.732,3.5,17.5C3.5,17.5,3.5,8.30295,3.5,8.30295C3.5,8.30295,10.5,2.8585000000000003,10.5,2.8585000000000003C10.5,2.8585000000000003,17.5,8.30295,17.5,8.30295C17.5,8.30295,17.5,17.5,17.5,17.5C17.5,17.732,17.4078,17.9547,17.2437,18.1187C17.0796,18.2828,16.857,18.375,16.625,18.375C16.625,18.375,14,18.375,14,18.375C14,18.375,14,18.375,14,18.375Z" fill-rule="evenodd" fill="#373737" fill-opacity="1"/></g></g></svg></a><a class="navi_link button" href="/blogs.html"><svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="#434343"><path d="M520-600v-240h320v240H520ZM120-440v-400h320v400H120Zm400 320v-400h320v400H520Zm-400 0v-240h320v240H120Zm80-400h160v-240H200v240Zm400 320h160v-240H600v240Zm0-480h160v-80H600v80ZM200-200h160v-80H200v80Zm160-320Zm240-160Zm0 240ZM360-280Z"/></svg></a><a class="navi_link button" href="/portfolio.html"><svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="#434343"><path d="M619-108q-11 11-25.5 17T563-85q-16 0-31-6t-26-17l-56-56q-11-11-16.5-24.5T427-216q-1-14 3.5-28t13.5-26l6-8-326-466 156-156 509 509q11 11 17 25.5t6 30.5q0 16-6 31t-17 26L619-108ZM507-335l113-112-340-340-52 52 279 400Zm56 170 169-169-56-57-170 170 57 56Zm-56-170 113-112-113 112Z"/></svg></a><a class="navi_link button" href="/about.html"><svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="#434343"><path d="M194-80v-395h80v315h280v-193l105-105q29-29 45-65t16-77q0-40-16.5-76T659-741l-25-26-127 127H347l-43 43-57-56 67-67h160l160-160 82 82q40 40 62 90.5T800-600q0 57-22 107.5T716-402l-82 82v240H194Zm197-187L183-475q-11-11-17-26t-6-31q0-16 6-30.5t17-25.5l84-85 124 123q28 28 43.5 64.5T450-409q0 40-15 76.5T391-267Z"/></svg></a></div>
        <div class="page_description">
          <h1 class="title">ğŸš¯ Unreal 5 åƒåœ¾å›æ”¶æºç æ¢³ç†</h1>
          <hr>
          <div class="sub_info">
            <p class="date">2025-06-05</p>
            <div class="type_tags">
              <p class="tag">Unreal</p>
              <p class="tag">Cpp</p>
              <p class="type">Dev</p>
            </div>
          </div>
        </div>
        <div class="page_content">
          <blockquote>
            <t class="">ä¸ºäº†ä½¿ä»£ç æ›´åŠ ç®€æ´æ˜“è¯»ï¼Œæœ¬æ–‡å‡ºç°çš„ UE æºä»£ç ä¼šå»é™¤æ‰è¾“å‡ºæ—¥å¿—çš„éƒ¨åˆ†ï¼Œç”¨ //...log æ¥è¡¨ç¤ºï¼Œé™¤æ­¤ä»¥å¤–ï¼Œæœ¬æ–‡ä¼šç”¨ ... æ¥è¡¨ç¤ºçœç•¥çš„ä»£ç ã€‚</t>
          </blockquote>
          <p>
            <t class="">æœ¬æ–‡ä½¿ç”¨çš„ UE æºç ç‰ˆæœ¬ä¸º 5.5.4ã€‚åœ¨ UE 5.0ï¼Œå¢é‡å›æ”¶æˆä¸ºäº†é»˜è®¤å¼€å¯çš„é€‰é¡¹ï¼Œä¹Ÿè¿æ¥äº†åŒ…æ‹¬å¹¶è¡Œå›æ”¶åœ¨å†…çš„åƒåœ¾å›æ”¶æ›´æ–°ã€‚å¦‚ API æœ‰æ‰€å‡ºå…¥ï¼Œè¯·ä»¥ 5.5.4 ä¸ºå‡†ã€‚</t>
          </p>
          <h1 id="heading1_0" index-text="I">
            <t class="">å‰è¨€</t>
          </h1>
          <h2 id="heading2_0">
            <t class="">åƒåœ¾å›æ”¶æ¦‚å¿µ</t>
          </h2>
          <p>
            <t class="">UE 5 é‡‡ç”¨æ ‡è®°æ¸…æ‰«çš„åƒåœ¾å›æ”¶ç­–ç•¥ï¼ŒåŒæ—¶æ”¯æŒå¢é‡å›æ”¶å’Œé›†ç¾¤ä¼˜åŒ–è®¡æ•°ã€‚è¿™ä¸€å°èŠ‚ä¼šæ¦‚å¿µæ€§åœ°ä»‹ç»ä¸€ä¸‹è¿™äº›åè¯åŠå…¶æ€æƒ³ã€‚å¦‚æœè¯»è€…å·²ç»å¯¹æ­¤ç†Ÿæ‚‰ï¼Œè¯·ç›´æ¥è·³è¿‡æ­¤å°èŠ‚ã€‚</t>
          </p>
          <ul>
            <li>
              <t class="">åƒåœ¾å›æ”¶ï¼šåƒåœ¾å›æ”¶æˆ–è€…è¯´åƒåœ¾å›æ”¶å™¨æ˜¯ä¸€æ®µå®šæœŸè¿è¡Œçš„ç¨‹åºã€‚å®ƒä¼šæ£€æŸ¥å¯¹è±¡çš„å­˜æ´»çŠ¶æ€ï¼Œå¹¶é‡Šæ”¾æ­»äº¡å¯¹è±¡çš„å†…å­˜ã€‚æ‰€è°“â€œæ­»äº¡â€çš„å¯¹è±¡ï¼Œå°±æ˜¯åœ¨ç¨‹åºä¸­æ°¸è¿œæ— æ³•å†è¢«è®¿é—®çš„å¯¹è±¡ï¼Œä¹Ÿæ˜¯â€œåƒåœ¾å›æ”¶â€ä¸­çš„â€œåƒåœ¾â€ã€‚</t>
            </li>
            <li>
              <t class="">å¯¹è±¡å›¾ï¼ˆObjects Graphï¼‰ï¼šå¯¹è±¡å›¾æ˜¯æŒ‡å¯¹è±¡å’Œå¯¹è±¡çš„å¼•ç”¨å…³ç³»æ„æˆçš„æœ‰å‘å›¾ï¼Œå®ƒæè¿°äº†å¯¹è±¡ä¹‹é—´çš„å¼•ç”¨å…³ç³»ã€‚</t>
            </li>
            <li>
              <t class="">æ ‡è®°æ¸…æ‰«ï¼ˆMark-Sweepï¼‰ï¼šæ˜¯ç°ä»Šæœ€å¸¸ç”¨çš„åƒåœ¾å›æ”¶ç­–ç•¥ã€‚å®ƒçš„åŸºæœ¬æ€æƒ³æ˜¯ä»ä¸€äº›ç‰¹æ®Šçš„â€œæ ¹å¯¹è±¡â€å¼€å§‹ï¼Œæ ¹æ®å¯¹è±¡ä¹‹é—´çš„å¼•ç”¨ç®¡çº¿ï¼Œå®Œæ•´åœ°éå†å¯¹è±¡å›¾ã€‚æ‰€æœ‰è¢«éå†å¯¹è±¡ä¼šè¢«æ‰“ä¸Šâ€œå¯è¾¾â€æ ‡è®°ã€‚æ¥ç€ï¼Œå†éå†ä¸€éæ‰€æœ‰å¯¹è±¡ï¼Œå¦‚æœä¸€ä¸ªå¯¹è±¡æ²¡æœ‰è¢«æ‰“ä¸Šå¯è¾¾æ ‡è®°ï¼Œæˆ‘ä»¬è®¤ä¸ºå®ƒæ˜¯æ­»äº¡çš„ã€‚å†æ ‡è®°æ¸…æ‰«ä¸­ï¼Œæˆ‘ä»¬è®¤ä¸ºå¯¹è±¡çš„â€œå­˜æ´»æ€§â€å’Œâ€œå¯è¾¾æ€§â€æ˜¯ç­‰ä»·çš„ã€‚æ ¹å¯¹è±¡åœ¨ UE ä¸­æœ‰ </t>
              <t class="code">UWorld</t>
              <t class=""> ç­‰ï¼Œä¹Ÿå¯ä»¥äººä¸ºæŒ‡å®šã€‚</t>
            </li>
            <li>
              <t class="">å¢é‡å›æ”¶ï¼ˆIncrementalï¼‰ï¼šâ€œå¢é‡å›æ”¶â€çš„æ€æƒ³æ˜¯å°†ä¸€æ¬¡åƒåœ¾å›æ”¶åˆ†æˆå¤šä¸ªå°æ®µåœ¨ä¸åŒçš„æ—¶é—´æ‰§è¡Œï¼Œè¿™æ ·åˆ†æ•£äº†ä¸€æ¬¡åƒåœ¾å›æ”¶çš„æ—¶é•¿ï¼Œå‡å°‘äº†ç¨‹åºå¡é¡¿çš„å¯èƒ½æ€§ã€‚å¢é‡å›æ”¶ä¹Ÿé¢ä¸´ç€æŒ‘æˆ˜ï¼Œä¾‹å¦‚å¯¹è±¡å›¾åœ¨è¿è¡Œæ—¶æ˜¯å˜åŒ–çš„ã€‚å¢é‡å›æ”¶éœ€è¦ä¸€äº›å¼‚æ­¥å®‰å…¨æœºåˆ¶ï¼Œè¿™äº›åœ¨ä¸‹æ–‡ä¸­éƒ½ä¼šä»‹ç»ã€‚</t>
            </li>
            <li>
              <t class="">å…¨é‡å›æ”¶ï¼ˆFullï¼‰ï¼šå…¨é‡å›æ”¶æ˜¯ä¸ºäº†å’Œå¢é‡å›æ”¶åŒºåˆ†è€Œå­˜åœ¨çš„åè¯ï¼Œæœ‰äº†å¢é‡å›æ”¶ä¹‹åï¼Œä¹‹å‰çš„â€œä¸€æ¬¡è¿›è¡Œå…¨éƒ¨å›æ”¶â€çš„è¡Œä¸ºå°±æ˜¯å…¨é‡å›æ”¶ã€‚</t>
            </li>
            <li>
              <t class="">å¯¹è±¡ç°‡ï¼ˆClusterï¼‰ï¼šæ˜¯ä¸€ç§å°†å¼ºç›¸å…³çš„å¯¹è±¡æ”¾åœ¨ä¸€èµ·çš„æ•°æ®ç»“æ„ï¼Œç”¨äºå‡å°‘å¯¹è±¡å›¾çš„éå†æ¬¡æ•°</t>
            </li>
          </ul>
          <h2 id="heading2_1">
            <t class="">ç« èŠ‚å®‰æ’</t>
          </h2>
          <p>
            <t class="">æœ¬æ–‡å°†åœ¨ç¬¬ä¸€ç« ä¸­æ¦‚å¿µæ€§åœ°ä»‹ç» UE 5 ä¸­åƒåœ¾å›æ”¶çš„ç¼–ç¨‹èŒƒå¼ï¼Œæå‰äº†è§£è¿™äº›æ€æƒ³æœ‰åŠ©äºåç»­æºç çš„é˜…è¯»ã€‚æ¥ç€ï¼Œæœ¬æ–‡å°†ä¼šåˆ†ä¸ºä¸‰ä¸ªç« èŠ‚ï¼Œç”±æµ…å…¥æ·±çš„å¯¹åƒåœ¾å›æ”¶æœºåˆ¶çš„æºç è¿›è¡Œè§£æã€‚</t>
          </p>
          <ul>
            <li>
              <t class="">UE 5 åƒåœ¾å›æ”¶ç¼–ç¨‹èŒƒå¼</t>
            </li>
            <li>
              <t class="">åƒåœ¾å›æ”¶çš„è§¦å‘æœºåˆ¶</t>
            </li>
            <li>
              <t class="">åƒåœ¾å›æ”¶è¿‡ç¨‹</t>
            </li>
            <li>
              <t class="">å¼•ç”¨ä¸å¯¹è±¡å›¾</t>
            </li>
          </ul>
          <h1 id="heading1_1" index-text="II">
            <t class="">UE 5 åƒåœ¾å›æ”¶ç¼–ç¨‹èŒƒå¼</t>
          </h1>
          <h2 id="heading2_2">
            <t class="">å¢é‡å›æ”¶</t>
          </h2>
          <p>
            <t class="">UE 5 çš„å¢é‡å›æ”¶çŠ¶æ€æ˜¯é€šè¿‡å…¨å±€çš„åŸå­å˜é‡æ¥ç®¡ç†çš„ã€‚å¼•æ“æ£€æŸ¥å¢é‡å›æ”¶çš„çŠ¶æ€é€šå¸¸ä¼šä½¿ç”¨ </t>
            <t class="code">IsIncrementalPurgePending()</t>
            <t class=""> å‡½æ•°ã€‚</t>
          </p>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang rss-ignore">c++</div>
              <pre><code class="language-c++">// GarbageCollection.cpp
std::atomic&lt;bool&gt; GObjIncrementalPurgeIsInProgress = false;

// GarbageCollection.cpp
bool IsIncrementalPurgePending()
{
  return GObjIncrementalPurgeIsInProgress || GObjPurgeIsRequired;
}</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <p>
            <t class="">åœ¨å¢é‡å›æ”¶ä¸­ï¼Œå¼•æ“å¾€å¾€ä¼šåœ¨éœ€è¦è·¨å¸§å·¥ä½œçš„åœºæ™¯ä¸­ï¼Œä½¿ç”¨å…¨å±€å˜é‡æˆ–è€…æˆå‘˜å˜é‡ç¼“å­˜æ¥å­˜å‚¨æ²¡æœ‰å®Œæˆçš„å·¥ä½œï¼Œå¹¶åœ¨ä¸‹ä¸€å¸§æ—¶ç»§ç»­ä½¿ç”¨ã€‚å› ä¸ºæœ‰è®¸å¤šå·¥ä½œéœ€è¦åœ¨å»¶è¿Ÿæ‰§è¡Œï¼Œå› æ­¤åƒåœ¾å›æ”¶çš„æºä»£ç ä¼šå¤§é‡å‡ºç° â€œPendingâ€ ä¸€è¯ï¼Œå…¶è¡¨ç¤ºâ€œå¾…å¤„ç†çš„â€ã€‚</t>
          </p>
          <p>
            <t class="">æ­¤å¤–ï¼ŒUE 5 å…è®¸å¼€å‘è€…è®¾ç½®åƒåœ¾å›æ”¶åœ¨ä¸€å¸§ä¸­çš„æ—¶é—´é™åˆ¶ï¼ˆTime Limitï¼‰ï¼Œè¿™ä¸ªæ—¶é—´é™åˆ¶ä½¿ç”¨ </t>
            <t class="code">GIncrementalGatherTimeLimit</t>
            <t class=""> å­˜å‚¨ï¼Œé»˜è®¤å€¼ä¸º </t>
            <t class="code">0.0</t>
            <t class="">ï¼Œä»£è¡¨æ²¡æœ‰é™åˆ¶ã€‚æ˜¯å¦è¶…æ—¶å¹¶æ²¡æœ‰ç»Ÿä¸€çš„å‡½æ•°ï¼Œå®ƒä¼šåœ¨å…·ä½“çš„æƒ…æ™¯ä¸‹è¢«è®¡ç®—ï¼Œä¾‹å¦‚ä¸‹é¢çš„ä»£ç </t>
          </p>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang rss-ignore">c++</div>
              <pre><code class="language-c++">// GarbageCollection.cpp/IncrementalPurgeGarbage()
bTimeLimitReached = UnhashUnreachableObjects(bUseTimeLimit, TimeLimit);</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <p>
            <t class="">åœ¨ä¸‹æ–‡ä¸­ï¼Œæœ¬æ–‡ä¼šç”¨â€œè¶…æ—¶â€æ¥è¡¨è¿°åƒåœ¾å›æ”¶æ‰§è¡Œçš„æ—¶é—´å·²ç»è¶…è¿‡äº†å¸§çš„é¢„ç®—æ—¶é—´ã€‚</t>
          </p>
          <p>
            <t class="">æ­¤å¤–ï¼Œå¢é‡å›æ”¶çš„ä»£ç ä¸å…¨é‡å›æ”¶çš„ä»£ç å¾€å¾€æ··åˆåœ¨ä¸€èµ·ï¼Œä¸€èˆ¬é€šè¿‡ </t>
            <t class="code">bFullPurage</t>
            <t class=""> ç±»ä¼¼çš„å­—çœ¼æ¥æ ‡è®°ã€‚</t>
          </p>
          <h2 id="heading2_3">
            <t class="">å¤šçº¿ç¨‹ä¸å¼‚æ­¥ä¼˜åŒ–</t>
          </h2>
          <p>
            <t class="">åƒåœ¾å›æ”¶å·¥ä½œå‘ç”Ÿåœ¨æ¸¸æˆçº¿ç¨‹ä¸­ã€‚ä½†æ˜¯åœ¨å±€éƒ¨çš„å·¥ä½œä¸­ï¼Œä¹Ÿä¼šè¿›è¡Œå¤šçº¿ç¨‹ä¼˜åŒ–ã€‚UE 5 ä¸­åƒåœ¾å›æ”¶ä½¿ç”¨ä»»åŠ¡å›¾ï¼ˆTask Graphï¼‰ç³»ç»Ÿä¸­çš„ä¸€äº›åŠŸèƒ½æ¯”å¦‚</t>
          </p>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang rss-ignore">c++</div>
              <pre><code class="language-c++">// GarbageCollection.cpp/GatherUnreachableObjects
ParallelFor( TEXT(&quot;GC.GatherUnreachable&quot;), ...)</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <p>
            <t class="">ä¹Ÿä½¿ç”¨äº†æ›´åŠ åº•å±‚çš„ä¸“ä¸º GC è®¾è®¡çš„ç¨‹åºã€‚æ¯”å¦‚å¯è¾¾æ€§åˆ†æç›¸å…³çš„ </t>
            <t class="code">ReferenceChainSearch.cpp</t>
            <t class=""> ã€‚</t>
          </p>
          <p>
            <t class="">æ­¤å¤–ï¼ŒUE ä½¿ç”¨äº†ä¸€ä¸ª </t>
            <t class="code">FGCCSyncObject</t>
            <t class=""> çš„å•ä¾‹æ¨¡å¼çš„é”æ¥ç®¡ç†å¼‚æ­¥èµ„æºã€‚åœ¨ä½¿ç”¨å…¨å±€å¼‚æ­¥èµ„æºæ—¶éœ€è¦ä¸Šé”å’Œè§£é”ã€‚é”é‡Œæœ¬èº«ä¸å­˜å‚¨ä»»ä½•èµ„æºçš„æŒ‡é’ˆï¼Œé”åªæ˜¯èµ·è®©å…¶å®ƒçº¿ç¨‹ç­‰å¾…çš„ä½œç”¨ï¼Œèµ„æºæ˜¯ä»¥å…¨å±€å˜é‡çš„å½¢å¼å­˜åœ¨çš„ï¼Œå› æ­¤å¼•æ“ä¸€å®šè¦åœ¨ä½¿ç”¨å…¨å±€èµ„æºæ—¶ç¡®ä¿æ‰‹å·¥ä¸Šé”å’Œè§£é”ã€‚ä¸ä¹‹ç›¸å…³çš„ä¸¤ä¸ªå‡½æ•°æ˜¯ </t>
            <t class="code">AcquireGCLock()</t>
            <t class=""> å’Œ </t>
            <t class="code">ReleaseGCLock()</t>
            <t class="">ï¼Œçœ‹åˆ°ç±»ä¼¼å­—çœ¼è¯´æ˜æ˜¯ä¸Šé”æˆ–è§£é”åƒåœ¾å›æ”¶å¼ºç›¸å…³çš„èµ„æºã€‚</t>
          </p>
          <h1 id="heading1_2" index-text="III">
            <t class="">åƒåœ¾å›æ”¶çš„è§¦å‘æœºåˆ¶</t>
          </h1>
          <h2 id="heading2_4">
            <t class="">å¼ºåˆ¶åƒåœ¾å›æ”¶</t>
          </h2>
          <p>
            <t class="">æƒ³è¦äº†è§£åƒåœ¾å›æ”¶ä»ä½•è§¦å‘ï¼Œæ‰§è¡Œäº†ä»€ä¹ˆï¼Œä¸€ä¸ªç®€å•çš„æƒ³æ³•æ˜¯ä»å¼ºåˆ¶åƒåœ¾å›æ”¶å…¥æ‰‹ã€‚æˆ‘ä»¬å…ˆä» </t>
            <t class="code">ForceGarbageCollection()</t>
            <t class=""> å‡½æ•°çš„æºä»£ç å¼€å§‹é˜…è¯»ã€‚</t>
          </p>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang rss-ignore">c++</div>
              <pre><code class="language-c++">// UnrealEngine.cpp
void UEngine::ForceGarbageCollection(bool bForcePurge/*=false*/)
{
  TimeSinceLastPendingKillPurge = 1.0f + GetTimeBetweenGarbageCollectionPasses();
  bFullPurgeTriggered = bFullPurgeTriggered || bForcePurge;
  //...log
}</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <ul>
            <li>
              <t class="code">bForcePurge</t>
              <t class=""> è¡¨ç¤ºè¿™æ¬¡å¼ºåˆ¶å›æ”¶æ˜¯å¦æ˜¯ä¸€æ¬¡å…¨é‡å›æ”¶ï¼Œä¸ä¹‹ç›¸å¯¹çš„æ˜¯å¢é‡å›æ”¶ </t>
              <t class="code">Incremental Purge</t>
            </li>
            <li>
              <t class="code">TimeSinceLastPendingKillPurge</t>
              <t class=""> ç§æœ‰æˆå‘˜å˜é‡çš„ä½œç”¨æ˜¯è®°å½•è·ç¦»ä¸Šä¸€æ¬¡æ¸…é™¤å¾…é”€æ¯çš„å¯¹è±¡çš„æ—¶é—´ï¼Œç”¨äºåˆ¤æ–­åƒåœ¾å›æ”¶æ¡ä»¶</t>
            </li>
            <li>
              <t class="code">GetTimeBetweenGarbageCollectionPasses()</t>
              <t class=""> ç”¨äºè·å–ä¸¤æ¬¡åƒåœ¾å›æ”¶ä¹‹é—´çš„æ—¶é—´é—´éš”</t>
            </li>
            <li>
              <t class="code">bFullPurgeTriggered</t>
              <t class=""> ç§æœ‰æˆå‘˜å˜é‡çš„ä½œç”¨æ˜¯æ ‡è®°ä¸‹ä¸€æ¬¡åƒåœ¾å›æ”¶æ˜¯å¦æ˜¯ä¸€æ¬¡å…¨é‡å›æ”¶</t>
            </li>
          </ul>
          <p>
            <t class="">å¯ä»¥å‘ç°ï¼Œä»£ç åœ¨æ‰§è¡Œå¼ºåˆ¶åƒåœ¾å›æ”¶æ—¶ï¼Œå°† </t>
            <t class="code">TimeSinceLastPendingKillPurge</t>
            <t class=""> èµ‹å€¼ä¸º </t>
            <t class="code">GetTimeBetweenGarbageCollectionPasses() + 1.0</t>
            <t class=""> ã€‚è¿™ä½¿å¾—åƒåœ¾å›æ”¶æ¡ä»¶å°†è¢«è§¦å‘ã€‚æ¥ä¸‹æ¥æœ¬æ–‡å…·ä½“ä»‹ç»ä¸€ä¸‹æ¡ä»¶åƒåœ¾å›æ”¶çš„ä»£ç ã€‚</t>
          </p>
          <h2 id="heading2_5">
            <t class="">æ¡ä»¶åƒåœ¾å›æ”¶</t>
          </h2>
          <p>
            <t class="">ä¸Šæ–‡æåˆ°äº†â€œåƒåœ¾å›æ”¶æ¡ä»¶â€ï¼Œè¿™äº›æ¡ä»¶ä¼šåœ¨æ¯å¸§éƒ½è¢«è°ƒç”¨çš„</t>
            <t class="code">ConditionalCollectGarbage()</t>
            <t class="">å‡½æ•°ä¸­è¢«åˆ¤æ–­ï¼Œå…¶ç›¸å…³çš„ä»£ç å¦‚ä¸‹ï¼š</t>
          </p>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang rss-ignore">c++</div>
              <pre><code class="language-c++">// UnrealEngine.cpp
void UEngine::ConditionalCollectGarbage()
{
  ...
  const float TimeBetweenPurgingPendingKillObjects = GetTimeBetweenGarbageCollectionPasses(bHasPlayersConnected);
  ...
  // Perform incremental purge update if it's pending or in progress.
  else if (!IsIncrementalPurgePending()
    // Purge reference to pending kill objects every now and so often.
    &amp;&amp; (TimeSinceLastPendingKillPurge &gt; TimeBetweenPurgingPendingKillObjects) &amp;&amp; TimeBetweenPurgingPendingKillObjects &gt; 0.f)
  ...
}</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <ul>
            <li>
              <t class="code">ConditionalCollectGarbage()</t>
              <t class=""> å‡½æ•°ä¼šåœ¨ </t>
              <t class="code">UWord::Tick</t>
              <t class=""> ä¸­è¢«æ¯å¸§è°ƒç”¨</t>
            </li>
            <li>
              <t class="code">GetTimeBetweenGarbageCollectionPasses()</t>
              <t class=""> å‡½æ•°æœ‰æ— å‚å’Œæœ‰ä¸€ä¸ªå‚çš„ä¸¤ä¸ªé‡è½½</t>
            </li>
          </ul>
          <p>
            <t class="">åˆ°è¿™é‡Œï¼Œå·²ç»å¯ä»¥ç†è§£ UE åƒåœ¾å›æ”¶çš„å¤§è‡´è§¦å‘æœºåˆ¶ã€‚ç®€å•æ¥è¯´ï¼Œåƒåœ¾å›æ”¶ç³»ç»Ÿä¼šè¿›è¡Œè®¡æ—¶ï¼Œæ¯ç»è¿‡ä¸€å®šé—´éš”è§¦å‘ä¸€æ¬¡åƒåœ¾å›æ”¶ã€‚åƒåœ¾å›æ”¶è®¡æ—¶ç”± </t>
            <t class="code">UEngine</t>
            <t class=""> çš„ </t>
            <t class="code">TimeSinceLastPendingKillPurge</t>
            <t class=""> æˆå‘˜å˜é‡è´Ÿè´£ï¼Œè€Œé—´éš”åˆ™é€šè¿‡ </t>
            <t class="code">GetTimeBetweenGarbageCollectionPasses()</t>
            <t class=""> å‡½æ•°è·å–ï¼š</t>
          </p>
          <p>
            <t class="">åƒåœ¾å›æ”¶çš„é»˜è®¤å›æ”¶é—´éš”ä¸º </t>
            <t class="code">60.0</t>
            <t class="">ï¼Œç”±ä¸€ä¸ªé™æ€å˜é‡å­˜å‚¨ã€‚å½“è¿è¡Œæœºå™¨ä¸ºæœåŠ¡å™¨ä¸”æ²¡æœ‰ç©å®¶è¿å…¥æ—¶ï¼Œé—´éš”ä¼šä¹˜ä»¥é»˜è®¤ä¸º </t>
            <t class="code">10.0</t>
            <t class=""> çš„ä¸€ä¸ªé™æ€å˜é‡ã€‚æ­¤å¤–ï¼Œå¦‚æœå½“å‰ç©ºä½™å†…å­˜å°‘äºè®¾å®šçš„ </t>
            <t class="code">GLowMemoryMemoryThresholdMB</t>
            <t class=""> å€¼ï¼Œåˆ™ä¼šæ— è§†ä¸Šé¢çš„è§„åˆ™ï¼Œä½¿ç”¨é»˜è®¤å€¼ä¸º </t>
            <t class="code">30.0</t>
            <t class=""> çš„é™æ€å˜é‡ï¼Œä¼šå¢åŠ å›æ”¶é¢‘ç‡ï¼ˆå¦‚æœé»˜è®¤å›æ”¶é—´éš”æ¯”ä½å†…å­˜å›æ”¶é—´éš”è¿˜å°ï¼Œé»˜è®¤å›æ”¶é—´éš”ï¼‰ã€‚ä¸‹é¢æ˜¯ç›¸å…³å˜é‡çš„è¡¨æ ¼ã€‚</t>
          </p>
          <div class="table">
            <table>
              <tr>
                <td>æƒ…å†µ</td>
                <td>å›æ”¶é—´éš”é»˜è®¤å€¼/s</td>
                <td>ç›¸å…³å˜é‡å</td>
              </tr>
              <tr>
                <td>é»˜è®¤æƒ…å†µ</td>
                <td>60.0</td>
                <td>GTimeBetweenPurgingPendingKillObjects</td>
              </tr>
              <tr>
                <td>æœåŠ¡å™¨ä¸”æ²¡æœ‰ç©å®¶</td>
                <td>60.0 * 10.0</td>
                <td>GTimeBetweenPurgingPendingKillObjectsOnIdleServerMultiplierï¼ˆæ— æœåŠ¡å™¨æ—¶çš„é—´éš”ç³»æ•°ï¼‰</td>
              </tr>
              <tr>
                <td>ä½å†…å­˜</td>
                <td>30.0</td>
                <td>GLowMemoryMemoryThresholdMBï¼ˆä½å†…å­˜é˜ˆå€¼ï¼‰, GLowMemoryTimeBetweenPurgingPendingKillObjectsï¼ˆä½å†…å­˜æ—¶é—´éš”ï¼‰</td>
              </tr>
            </table>
          </div>
          <h3 id="heading3_0">
            <t class="code">ConditionalCollectGarbage</t>
            <t class=""> è¯¦è§£</t>
          </h3>
          <p>
            <t class="">åˆšåˆšæœ¬æ–‡ä»‹ç»äº† </t>
            <t class="code">ConditionalCollectGarbage</t>
            <t class=""> å±€éƒ¨çš„é€»è¾‘å’Œè·å–é—´éš”çš„é€»è¾‘ï¼Œæ¥ç€ä»æ•´ä½“ä¸Šæ¥çœ‹ä¸€ä¸‹è¿™ä¸ªå‡½æ•°ã€‚</t>
          </p>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang rss-ignore">c++</div>
              <pre><code class="language-c++">// UnrealEngine.cpp

void UEngine::ConditionalCollectGarbage()
{
  if (GFrameCounter != LastGCFrame)</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <ul>
            <li>
              <t class="code">GFrameCounter</t>
              <t class=""> æ˜¯å¼•æ“çš„å…¨å±€å¸§å·</t>
            </li>
            <li>
              <t class="code">LastGCFrame</t>
              <t class=""> æ˜¯ä¸Šä¸€æ¬¡è§¦å‘åƒåœ¾å›æ”¶çš„å¸§å·</t>
            </li>
          </ul>
          <p>
            <t class="">è¿™ä¸ªæ¡ä»¶åˆ¤æ–­é¿å…ä¸€å¸§å†…è§¦å‘å¤šæ¬¡åƒåœ¾å›æ”¶ã€‚è¿™æ®µ if çš„ç»“å°¾æ˜¯ä¸€ä¸ªå¢é‡å›æ”¶çš„æ¡ä»¶åˆ¤æ–­ï¼Œæˆ‘ä»¬æŠŠå®ƒæ’å…¥åœ¨æ­¤ï¼š</t>
          </p>
          <hr class="divider_block">
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang rss-ignore">c++</div>
              <pre><code class="language-c++">  else if (IsIncrementalReachabilityAnalysisPending())
  {
    PerformIncrementalReachabilityAnalysis(GetReachabilityAnalysisTimeLimit());
  }</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <ul>
            <li>
              <t class="code">IsIncrementalReachabilityAnalysisPending()</t>
              <t class=""> è·å–å¢é‡åƒåœ¾å›æ”¶æ˜¯å¦å¾…æ‰§è¡Œ</t>
            </li>
          </ul>
          <p>
            <t class="">æ„æ€æ˜¯å¦‚æœå¢é‡åƒåœ¾å›æ”¶çš„å¯è¾¾æ€§åˆ†ææ²¡æœ‰å®Œæˆï¼Œç»§ç»­è¿›è¡Œå¯è¾¾æ€§åˆ†æã€‚</t>
          </p>
          <hr class="divider_block">
          <p>
            <t class="">å›åˆ°åŸæ¥ä»£ç çš„ä½ç½®ï¼š</t>
          </p>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang rss-ignore">c++</div>
              <pre><code class="language-c++">  {
    QUICK_SCOPE_CYCLE_COUNTER(STAT_ConditionalCollectGarbage);

#if !(UE_BUILD_SHIPPING || UE_BUILD_TEST)
    if (CVarStressTestGCWhileStreaming.GetValueOnGameThread() &amp;&amp; IsAsyncLoading())
    {
      CollectGarbage(GARBAGE_COLLECTION_KEEPFLAGS, true);
    }
    else if (CVarForceCollectGarbageEveryFrame.GetValueOnGameThread())
    {
      CollectGarbage(GARBAGE_COLLECTION_KEEPFLAGS, true);
    }
    else
#endif</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <p>
            <t class="code">!(UE_BUILD_SHIPPING || UE_BUILD_TEST)</t>
            <t class=""> å®å£°æ˜è¿™æ®µä»£ç ä»…åœ¨éå‘å¸ƒå’Œéæµ‹è¯•ä¸‹å¯ç”¨ï¼Œè¿™éƒ¨åˆ†ä»£ç ä¸å‹åŠ›æµ‹è¯•å’Œè°ƒè¯•ç›¸å…³ã€‚</t>
          </p>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang rss-ignore">c++</div>
              <pre><code class="language-c++">    {
      EGarbageCollectionType ForceTriggerPurge = ShouldForceGarbageCollection();
#if WITH_VERSE_VM || defined(__INTELLISENSE__)
      if (ForceTriggerPurge == EGarbageCollectionType::None &amp;&amp; UE::GC::ShouldFrankenGCRun())
      {
        ForceTriggerPurge = EGarbageCollectionType::Incremental;
      }
#endif
      if (ForceTriggerPurge != EGarbageCollectionType::None)
      {
        ForceGarbageCollection(ForceTriggerPurge == EGarbageCollectionType::Full);
      }</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <p>
            <t class="">è¿™æ®µä»£ç ä¸</t>
            <t class="bold">å¼ºåˆ¶</t>
            <t class="">åƒåœ¾å›æ”¶æœ‰å…³</t>
          </p>
          <ul>
            <li>
              <t class="code">EGarbageCollectionType</t>
              <t class=""> æšä¸¾æœ‰ä¸‰ç§å€¼</t>
            </li>
          </ul>
          <p>
            <t class="">åœ¨ </t>
            <t class="code">UEngine</t>
            <t class=""> ä¸­ </t>
            <t class="code">ShouldForceGarbageCollection()</t>
            <t class=""> æ°¸è¿œè¿”å› </t>
            <t class="code">None</t>
            <t class="">ã€‚åªæœ‰åœ¨ä½¿ç”¨ </t>
            <t class="code">VERSE</t>
            <t class=""> çš„æƒ…å†µä¸‹ï¼Œæ‰å¯èƒ½ä¼šä½¿ç”¨å¼ºåˆ¶å¢é‡å›æ”¶ã€‚æ¥ä¸‹æ¥ï¼Œå°±æ‰§è¡Œæ­£å¼çš„åƒåœ¾å›æ”¶ä»£ç äº†ã€‚</t>
          </p>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang rss-ignore">c++</div>
              <pre><code class="language-c++">      if (bFullPurgeTriggered)
      {
        if (TryCollectGarbage(GARBAGE_COLLECTION_KEEPFLAGS, true))
        {
          ForEachObjectOfClass(UWorld::StaticClass(),[](UObject* World)
          {
            CastChecked&lt;UWorld&gt;(World)-&gt;CleanupActors();
          });
          bFullPurgeTriggered = false;
          bShouldDelayGarbageCollect = false;
          TimeSinceLastPendingKillPurge = 0.0f;
        }
      }</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <ul>
            <li>
              <t class="code">bFullPurgeTriggered</t>
              <t class=""> æ ‡è®°æ˜¯å¦ä½¿ç”¨å…¨é‡åƒåœ¾å›æ”¶ï¼Œåœ¨æ‰§è¡Œåè¢«è®¾ä¸º </t>
              <t class="code">false</t>
            </li>
          </ul>
          <p>
            <t class="">å¦‚æœä½¿ç”¨å…¨é‡åƒåœ¾å›æ”¶ï¼Œåˆ™ä¼šè¿›è¡Œåƒåœ¾å›æ”¶è¡Œä¸ºï¼Œå³ </t>
            <t class="code">TryCollectGarbage</t>
            <t class=""> å’Œ </t>
            <t class="code">CleanupActors</t>
            <t class="">ï¼Œè¿™ä¸¤ä¸ªå‡½æ•°ä¼šåœ¨åé¢çš„å°èŠ‚è¿›è¡Œè¯¦ç»†çš„ä»‹ç»ã€‚å¦‚æœä¸è¿›è¡Œå…¨é‡å›æ”¶ï¼Œæ¥çœ‹ä¸‹é¢çš„éƒ¨åˆ†ã€‚</t>
          </p>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang rss-ignore">c++</div>
              <pre><code class="language-c++">      else
      {
        const bool bTestForPlayers = IsRunningDedicatedServer();
        bool bHasAWorldBegunPlay = false;
        bool bHasPlayersConnected = false;

        // Look for conditions in the worlds that would change the GC frequency
        for (const FWorldContext&amp; Context : WorldList) {
          if (UWorld* World = Context.World()) {
            if (World-&gt;HasBegunPlay()) {
              bHasAWorldBegunPlay = true;
            }

            if (bTestForPlayers &amp;&amp;
              World-&gt;NetDriver &amp;&amp;
              World-&gt;NetDriver-&gt;ClientConnections.Num() &gt; 0
            ) {
              bHasPlayersConnected = true;
            }

            // If we found the conditions we wanted, no need to continue iterating
            if (bHasAWorldBegunPlay &amp;&amp;
              (!bTestForPlayers || bHasPlayersConnected)
            ){
              break;
            }
          }
        }</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <p>
            <t class="">è¿™æ®µ for å¾ªç¯ç”¨äºå¯»æ‰¾å¯èƒ½æ”¹å˜ GC é¢‘ç‡çš„æƒ…å†µï¼Œå…·ä½“æ¥è¯´ï¼Œå’Œä¸Šæ–‡æè¿°è¿‡çš„ä¸€æ ·ï¼Œæ£€æŸ¥æœåŠ¡å™¨çš„æ‰€æœ‰ä¸–ç•Œæ˜¯å¦æœ‰ç©å®¶è¿æ¥ã€‚å…¶å¾—åˆ°çš„ç»“æœ </t>
            <t class="code">bHasPlayersConnected</t>
            <t class="">ï¼Œä¼šç”¨äºä¸Šæ–‡æåˆ°è¿‡çš„ </t>
            <t class="code">GetTimeBetweenGarbageCollectionPasses(bool)</t>
            <t class=""> å‡½æ•°ã€‚è¿™é‡Œæ²¡æœ‰ä½¿ç”¨æ— å‚ç‰ˆæœ¬çš„ </t>
            <t class="code">GetTimeBetweenGarbageCollectionPasses()</t>
            <t class=""> çš„ä¸»è¦åŸå› æ˜¯ï¼Œåœ¨è¿™æ®µé€»è¾‘ä¸­å¼•æ“è¿˜éœ€è¦è·å¾—ä¸–ç•Œçš„å¼€å§‹çŠ¶æ€ï¼Œä¹Ÿå°±æ˜¯ </t>
            <t class="code">bHasAWorldBegunPlay</t>
            <t class="">ã€‚ä¸‹é¢çš„ä»£ç ç«‹åˆ»å°±ä¼šç”¨åˆ°ï¼š</t>
          </p>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang rss-ignore">c++</div>
              <pre><code class="language-c++">        if (bHasAWorldBegunPlay)
        {
          TimeSinceLastPendingKillPurge += FApp::GetDeltaTime();

          const float TimeBetweenPurgingPendingKillObjects = GetTimeBetweenGarbageCollectionPasses(bHasPlayersConnected);

          // See if we should delay garbage collect for this frame
          if (bShouldDelayGarbageCollect)
          {
            bShouldDelayGarbageCollect = false;
          }
          else if (IsIncrementalReachabilityAnalysisPending())
          {
            SCOPE_CYCLE_COUNTER(STAT_GCMarkTime);
            PerformIncrementalReachabilityAnalysis(GetReachabilityAnalysisTimeLimit());
          }
          // Perform incremental purge update if it's pending or in progress.
          else if (!IsIncrementalPurgePending()
            // Purge reference to pending kill objects every now and so often.
            &amp;&amp; (TimeSinceLastPendingKillPurge &gt; TimeBetweenPurgingPendingKillObjects) &amp;&amp; TimeBetweenPurgingPendingKillObjects &gt; 0.f)
          {
            SCOPE_CYCLE_COUNTER(STAT_GCMarkTime);
            PerformGarbageCollectionAndCleanupActors();
          }
          else
          {
            SCOPE_CYCLE_COUNTER(STAT_GCSweepTime);
            float IncGCTime = GetIncrementalGCTimePerFrame();
            IncrementalPurgeGarbage(true, IncGCTime);
          }
        }
      }
    }</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <p>
            <t class="">è¿™æ®µä»£ç çš„å¤§è‡´é€»è¾‘æ˜¯ï¼Œåªæœ‰åœ¨è‡³å°‘ä¸€ä¸ªä¸–ç•Œå¼€å§‹è¿è¡Œæ—¶ï¼Œå¼•æ“æ‰ä¼šè®¡æ—¶å’Œåˆ¤æ–­åƒåœ¾å›æ”¶ï¼›åœ¨æœ‰ä¸Šä¸€å¸§ç•™ä¸‹çš„å¢é‡å›æ”¶çš„ä»»åŠ¡æ—¶ï¼Œç»§ç»­è¿›è¡Œå¢é‡å›æ”¶çš„å·¥ä½œï¼›å¦‚æœæ²¡æœ‰å¢é‡å›æ”¶ä»»åŠ¡ï¼Œåˆ™åˆ¤æ–­è®¡æ—¶æ˜¯å¦è¾¾åˆ°é—´éš”ï¼Œæ¥ç¡®å®šæ˜¯å¦éœ€è¦å¼€å¯æ–°ä¸€è½®çš„åƒåœ¾å›æ”¶ã€‚</t>
          </p>
          <ul>
            <li>
              <t class="code">PerformIncrementalReachabilityAnalysis()</t>
              <t class=""> è´Ÿè´£æ‰§è¡Œå¢é‡åƒåœ¾å›æ”¶çš„åˆ†æ­¥å¯è¾¾æ€§åˆ†æ</t>
            </li>
            <li>
              <t class="code">PerformGarbageCollectionAndCleanupActors()</t>
              <t class=""> è´Ÿè´£æ‰§è¡Œå…¨é‡åƒåœ¾å›æ”¶ï¼Œå†…å®¹ä¸ä¸Šæ–‡ä¸­ä»‹ç»çš„å…¨é‡åƒåœ¾å›æ”¶çš„é€»è¾‘ç±»ä¼¼ï¼Œå…¶ä¹Ÿä½¿ç”¨äº† </t>
              <t class="code">UEngine::TryCollectGarbage()</t>
              <t class=""> å’Œ </t>
              <t class="code">UWorld::CleanupActors</t>
              <t class=""> æ¥å›æ”¶å¯¹è±¡ã€‚ä¸‹æ–‡ä¼šå…·ä½“ä»‹ç»</t>
            </li>
            <li>
              <t class="code">IncrementalPurgeGarbage()</t>
              <t class=""> è´Ÿè´£é”€æ¯ </t>
              <t class="code">UObject</t>
              <t class=""> å’Œé‡Šæ”¾å†…å­˜ï¼Œè¿™æ—¶å¯è¾¾æ€§åˆ†æå·²ç»å®Œæˆï¼Œåé¢çš„ç« èŠ‚ä¼šå…·ä½“ä»‹ç»</t>
            </li>
          </ul>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang rss-ignore">c++</div>
              <pre><code class="language-c++">    if (const int32 Interval = CVarCollectGarbageEveryFrame.GetValueOnGameThread())
    {
      if (0 == (GFrameCounter % Interval))
      {
        ForceGarbageCollection(true);
      }
    }</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <p>
            <t class="">è¿™æ®µä»£ç è´Ÿè´£æ‰§è¡Œæ§åˆ¶å°å˜é‡å¯¹åƒåœ¾å›æ”¶å¼ºåˆ¶å¹²é¢„ï¼Œæ¯éš” </t>
            <t class="code">Interval</t>
            <t class=""> å¸§å¼ºåˆ¶è¿›è¡Œåƒåœ¾å›æ”¶ã€‚</t>
          </p>
          <ul>
            <li>
              <t class="code">CVarCollectGarbageEveryFrame</t>
              <t class=""> è·å–å¸§é—´éš”</t>
            </li>
          </ul>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang rss-ignore">c++</div>
              <pre><code class="language-c++">    else if (CVarContinuousIncrementalGC.GetValueOnGameThread() &gt; 0 &amp;&amp;
        !IsIncrementalReachabilityAnalysisPending() &amp;&amp;
        !IsIncrementalUnhashPending() &amp;&amp;
        !IsIncrementalPurgePending())
    {
      ForceGarbageCollection(false);
    }

    LastGCFrame = GFrameCounter;
  }</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <ul>
            <li>
              <t class="code">CVarContinuousIncrementalGC</t>
              <t class=""> å¯ç”¨æŒç»­å¢é‡ GC todo</t>
            </li>
          </ul>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang rss-ignore">c++</div>
              <pre><code class="language-c++">  else if (IsIncrementalReachabilityAnalysisPending())
  {
    PerformIncrementalReachabilityAnalysis(GetReachabilityAnalysisTimeLimit());
  }
}</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <p>
            <t class="">æœ€åï¼Œå¦‚å‰æ–‡æ’å…¥çš„ if çš„ç»“å°¾ã€‚å¦‚æœå¢é‡å›æ”¶çš„å¯è¾¾æ€§åˆ†æè¿˜æ²¡æœ‰å®Œæˆï¼Œè¿›è¡Œå¯è¾¾æ€§åˆ†æã€‚</t>
          </p>
          <h3 id="heading3_1">
            <t class="code">PerformGarbageCollectionAndCleanupActors()</t>
          </h3>
          <p>
            <t class="">ä¸Šæ–‡æåˆ°ï¼Œåœ¨æ‰§è¡Œå…¨é‡å›æ”¶æ—¶ï¼Œå¼•æ“ä¼šè°ƒç”¨ </t>
            <t class="code">PerformGarbageCollectionAndCleanupActors()</t>
            <t class=""> å‡½æ•°ã€‚å…¶æºä»£ç å¦‚ä¸‹ï¼š</t>
          </p>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang rss-ignore">c++</div>
              <pre><code class="language-c++">void UEngine::PerformGarbageCollectionAndCleanupActors()
{
  // We don't collect garbage while there are outstanding async load requests as we would need
  // to block on loading the remaining data.
  if (GPerformGCWhileAsyncLoading || !IsAsyncLoading())
  {
    bool bForcePurge = true;
    for (FWorldContext&amp; Context : WorldList)
    {
      UWorld* World = Context.World();
      if (World != nullptr &amp;&amp; World-&gt;IsGameWorld())
      {
        bForcePurge = false;
        break;
      }
    }</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <ul>
            <li>
              <t class="code">GPerformGCWhileAsyncLoading</t>
              <t class=""> è¡¨ç¤ºæ˜¯å¦å…è®¸åœ¨å¼‚æ­¥åŠ è½½æ—¶æ‰§è¡Œ GCï¼Œå…¶é…åˆ </t>
              <t class="code">IsAsyncLoading()</t>
              <t class=""> è¿›è¡Œå¼‚æ­¥åŠ è½½æ—¶æ˜¯å¦è§¦å‘ GC çš„åˆ¤æ–­</t>
            </li>
            <li>
              <t class="code">bForcePurge</t>
              <t class=""> é»˜è®¤ä¸º trueï¼Œä½†æ˜¯ä¸€æ—¦å‘ç°å­˜åœ¨æ´»è·ƒçš„æ¸¸æˆä¸–ç•Œï¼ˆ</t>
              <t class="code">World != nullptr &amp;&amp; World-&gt;IsGameWorld</t>
              <t class="">ï¼‰é‚£ä¹ˆå°±å–æ¶ˆå¼ºåˆ¶æ¸…ç†ã€‚è¿™æ ·æœ‰åŠ©äºå‡å°‘æ¸¸æˆå¡é¡¿ï¼Œä¼˜å…ˆä¿è¯æµç•…æ€§ã€‚</t>
            </li>
          </ul>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang rss-ignore">c++</div>
              <pre><code class="language-c++">    // Perform housekeeping.
    if (TryCollectGarbage(GARBAGE_COLLECTION_KEEPFLAGS, bForcePurge))
    {
      ForEachObjectOfClass(UWorld::StaticClass(), [](UObject* World)
      {
        CastChecked&lt;UWorld&gt;(World)-&gt;CleanupActors();
      });

      // Reset counter.
      TimeSinceLastPendingKillPurge = 0.0f;
      bFullPurgeTriggered = false;
      LastGCFrame = GFrameCounter;
    }
  }
}</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <p>
            <t class="">è¿™é‡Œå°±æ˜¯æ‰§è¡Œåƒåœ¾å›æ”¶çš„ä»£ç äº†ï¼Œä¸ä¸Šæ–‡ä¸­å…¨é‡å¼ºåˆ¶åƒåœ¾å›æ”¶æœ‰ååˆ†ç›¸ä¼¼çš„åœ°æ–¹ã€‚å…¶ä¸­é‡è¦çš„ä¸¤ä¸ªå‡½æ•°æ˜¯ </t>
            <t class="code">TryCollectGarbage</t>
            <t class=""> å’Œ </t>
            <t class="code">CleanupActors</t>
            <t class="">ï¼Œä¸‹é¢ä¸€ä¸ªå°èŠ‚ä¼šå¯¹ä¸¤è€…è¿›è¡Œé‡ç‚¹ä»‹ç»ã€‚</t>
          </p>
          <h1 id="heading1_3" index-text="IV">
            <t class="">åƒåœ¾å›æ”¶çš„æ‰§è¡Œè¿‡ç¨‹</t>
          </h1>
          <p>
            <t class="">ä¸Šæ–‡æåˆ°äº†ï¼Œåœ¨æ¡ä»¶åƒåœ¾å›æ”¶ä¸­ï¼ˆ</t>
            <t class="code">UEngine::ConditionalCollectGarbage</t>
            <t class="">ï¼‰ï¼Œåƒåœ¾å›æ”¶çš„è¿‡ç¨‹å‘ç”Ÿåœ¨ä¸¤å¤„ï¼Œä¸€å¤„æ˜¯å¼ºåˆ¶å…¨é‡åƒåœ¾å›æ”¶ï¼ˆ</t>
            <t class="code">Engine::bFullPurgeTriggered</t>
            <t class="">ï¼‰ï¼Œå¦ä¸€å¤„åœ¨ </t>
            <t class="code">PerformGarbageCollectionAndCleanupActors()</t>
            <t class=""> ä¸­ï¼Œä¸¤è€…çš„æ ¸å¿ƒé€»è¾‘æ˜¯ååˆ†ç›¸ä¼¼çš„ï¼Œæˆ‘ä»¬å…ˆçœ‹çœ‹ä¸¤è€…çš„ä»£ç ï¼š</t>
          </p>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang rss-ignore">c++</div>
              <pre><code class="language-c++">// if(bFullPurgeTriggered)
if (TryCollectGarbage(GARBAGE_COLLECTION_KEEPFLAGS, true))
{
  ForEachObjectOfClass(UWorld::StaticClass(),[](UObject* World)
  {
    CastChecked&lt;UWorld&gt;(World)-&gt;CleanupActors();
  });
  TimeSinceLastPendingKillPurge = 0.0f;
  bFullPurgeTriggered = false;
  bShouldDelayGarbageCollect = false;
}

// UEngine::PerformGarbageCollectionAndCleanupActors
if (TryCollectGarbage(GARBAGE_COLLECTION_KEEPFLAGS, bForcePurge))
{
  ForEachObjectOfClass(UWorld::StaticClass(), [](UObject* World)
  {
    CastChecked&lt;UWorld&gt;(World)-&gt;CleanupActors();
  });
  TimeSinceLastPendingKillPurge = 0.0f;
  bFullPurgeTriggered = false;
  LastGCFrame = GFrameCounter;
}</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <p>
            <t class="">å¦‚æºç ä¸­æ‰€ç¤ºï¼Œé¦–å…ˆä¼šè°ƒç”¨ </t>
            <t class="code">TryCollectGarbage()</t>
            <t class=""> å‡½æ•°ï¼Œæ¥ç€ä¼šéå†æ‰€æœ‰ä¸–ç•Œï¼ˆ</t>
            <t class="code">UWorld</t>
            <t class="">ï¼‰ï¼Œè°ƒç”¨å…¶ </t>
            <t class="code">CleanupActors()</t>
            <t class=""> å‡½æ•°ï¼Œæ¸…é™¤ </t>
            <t class="code">Actor</t>
            <t class="">ã€‚ä¸‹æ–‡ä¼šå…·ä½“ä»‹ç» </t>
            <t class="code">TryCollectGarbage()</t>
            <t class=""> å’Œ </t>
            <t class="code">CleanupActors()</t>
            <t class=""> çš„å·¥ä½œè¿‡ç¨‹ã€‚ éœ€è¦æ³¨æ„çš„ä¸€ç‚¹æ˜¯ï¼Œå¼ºåˆ¶å…¨é‡åƒåœ¾å›æ”¶å¹¶ä¸ä¼šå½±å“æ­£å¸¸çš„åƒåœ¾å›æ”¶å¸§è®¡æ•°ï¼ˆå› ä¸ºå¹¶æ²¡æœ‰æ›´æ–°</t>
            <t class="code">LastGCFrame</t>
            <t class="">ï¼‰ã€‚</t>
          </p>
          <h2 id="heading2_6">
            <t class="">å›æ”¶è¿‡ç¨‹ï¼š</t>
            <t class="code">TryCollectGarbage</t>
          </h2>
          <p>
            <t class="">ä¸‹æ–‡ä¸­ä¼šæ—¶å¸¸å‡ºç° </t>
            <t class="code">IsSuspended</t>
            <t class=""> è¿™ä»£è¡¨æ˜¯å¦å¤„äºå¢é‡å›æ”¶çš„æŒ‚èµ·ï¼ˆæˆ–ç§°æš‚åœï¼‰çŠ¶æ€ã€‚ä»¥åŠï¼Œå¯¹è±¡ç°‡ï¼ˆClusterï¼‰ä¸€è¯æŒ‡ä¸€ç³»åˆ—ç´§å¯†å…³è”çš„ </t>
            <t class="code">UObject</t>
            <t class="">ï¼Œä¾‹å¦‚ä¸€ä¸ª Actor å’Œå®ƒçš„ Sub Objectsã€‚æ˜¾ç„¶åƒåœ¾å›æ”¶ä¸­ä½¿ç”¨é›†ç¾¤å¯ä»¥å‡å°‘éå†æ¬¡æ•°ã€‚</t>
          </p>
          <p>
            <t class="code">TryCollectGarbage</t>
            <t class=""> å‡½æ•°ä¼šè°ƒç”¨ </t>
            <t class="code">GarbageColleciton.h</t>
            <t class=""> ä¸­çš„ </t>
            <t class="code">FReachabilityAnalysisState::PerformReachabilityAnalysisAndConditionallyPurgeGarbage</t>
            <t class=""> å‡½æ•°ï¼Œå®ƒçš„å¤§è‡´è¿‡ç¨‹ä¸ºï¼š</t>
          </p>
          <ul>
            <li>
              <t class="">è¿›è¡Œé¢„å›æ”¶ </t>
              <t class="code">UE::GC::PreCollectGarbageImpl&lt;true&gt;(ObjectKeepFlags);</t>
            </li>
            <li>
              <t class="">è¿›è¡Œå¯è¾¾æ€§åˆ†æ </t>
              <t class="code">PerformReachabilityAnalysis()</t>
              <t class="">;</t>
            </li>
            <li>
              <t class="">è¿›è¡Œåå›æ”¶ </t>
              <t class="code">UE::GC::PostCollectGarbageImpl&lt;true&gt;(ObjectKeepFlags);</t>
            </li>
          </ul>
          <p>
            <t class="">æœ¬å°èŠ‚å°†</t>
            <t class="bold">å¯è¾¾æ€§åˆ†æ</t>
            <t class="">å’Œ</t>
            <t class="bold">æ¸…æ‰«åˆ†å¼€</t>
            <t class="">è®²è¿°ã€‚</t>
          </p>
          <h3 id="heading3_2">
            <t class="">å¯è¾¾æ€§åˆ†æ</t>
          </h3>
          <p>
            <t class="">åœ¨å¯è¾¾æ€§åˆ†ææ—¶ï¼Œå­˜åœ¨ä¸­é—´å‡½æ•°ï¼Œå¦‚ </t>
            <t class="code">FReachabilityAnalysisState</t>
            <t class=""> çš„ </t>
            <t class="code">PerformReachabilityAnalysis()</t>
            <t class=""> å‡½æ•°ã€‚ä½†æ— è®ºä¸­é—´å‡½æ•°å¦‚ä½•ï¼Œå…¶åº•å±‚è°ƒç”¨çš„éƒ½æ˜¯ </t>
            <t class="code">FRealtimeGC::PerformReachabilityAnalysis</t>
            <t class=""> å‡½æ•°ï¼Œæ‰€ä»¥åœ¨æ­¤æˆ‘ä»¬ç€é‡çœ‹è¿™ä¸ªå‡½æ•°çš„æ‰§è¡Œé€»è¾‘ã€‚ä¸‹é¢æ˜¯å¯¹è¿™ä¸ªå‡½æ•°çš„åˆ†æ­¥åˆ†æï¼š</t>
          </p>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang rss-ignore">c++</div>
              <pre><code class="language-c++">// GarbageColleciton.cpp

void PerformReachabilityAnalysis(EObjectFlags KeepFlags, const EGCOptions Options) {
  LLM_SCOPE(ELLMTag::GC);

  const bool bIsGarbageTracking = !GReachabilityState.IsSuspended() &amp;&amp; Stats.bFoundGarbageRef;

  if (!GReachabilityState.IsSuspended()) {
    StartReachabilityAnalysis(KeepFlags, Options);
    // We start verse GC here so that the objects are unmarked prior to verse marking them
    StartVerseGC();
  }

  {
    const double StartTime = FPlatformTime::Seconds();

    while (true) {
      PerformReachabilityAnalysisPass(Options);

      if (GReachabilityState.IsSuspended()) {
// We may have suspended either via incremental timeout, or because verse GC is still marking.
// If we are not incremental, keep going while verse GC adds to GReachableObjects.
        if (EnumHasAnyFlags(Options, EGCOptions::IncrementalReachability)) {
          break;
        }
      }
      else if (Private::GReachableObjects.IsEmpty() &amp;&amp; Private::GReachableClusters.IsEmpty()) {
// We terminate verse GC here now that both sides have nothing left to mark.
// This check must happen only when !IsSuspended, so verse GC can no longer add to GReachableObjects.
        StopVerseGC();
        break;
      }
    }
    // ... time tracing
  }</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <p>
            <t class="">è¿™ä¸ª while å¾ªç¯ä¼šæ‰§è¡Œ </t>
            <t class="code">PerformReachabilityAnalysisPass</t>
            <t class="">ï¼Œè¿™æ˜¯è¿›è¡Œå¯è¾¾æ€§æ ‡è®°çš„ä¸»è¦å‡½æ•°ï¼Œå®ƒçš„ä½œç”¨æ˜¯æ­¥è¿›ä¸€æ¬¡å¯è¾¾æ€§åˆ†æï¼Œä¸‹æ–‡ä¼šå¯¹è¿™ä¸ªå‡½æ•°è¿›è¡Œè¯¦ç»†ä»‹ç»ã€‚å¯è¾¾æ€§åˆ†ææ˜¯åœ¨å¾ªç¯ä¸­ä¸æ–­æ­¥è¿›å®Œæˆçš„ï¼Œåœ¨è¿™ä¸¤ç§æƒ…å†µä¸‹æ‰ä¼šé€€å‡ºå¾ªç¯ï¼š</t>
          </p>
          <ul>
            <li>
              <t class="">å¢é‡æ¨¡å¼æŒ‚èµ·ï¼Œä¸€èˆ¬æ˜¯æ‰§è¡Œæ—¶é—´è¶…è¿‡ä¸€å¸§çš„æ—¶é—´é¢„ç®—ï¼Œè¿™æ—¶ä¼šç­‰åˆ°ä¸‹ä¸€å¸§å¤„ç†</t>
            </li>
            <li>
              <t class="">å¯è¾¾å¯¹è±¡æˆ–è€…å¯è¾¾å¯¹è±¡ç°‡ä¸ºç©ºï¼Œæ„å‘³ç€æ•°æ®å¤„ç†å®Œæ¯•</t>
            </li>
          </ul>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang rss-ignore">c++</div>
              <pre><code class="language-c++">PRAGMA_DISABLE_DEPRECATION_WARNINGS
  // Allowing external systems to add object roots. This can't be done through AddReferencedObjects
  // because it may require tracing objects (via FGarbageCollectionTracer) multiple times
  if (!GReachabilityState.IsSuspended())
  {
    const double StartTime = FPlatformTime::Seconds();
    FCoreUObjectDelegates::TraceExternalRootsForReachabilityAnalysis.Broadcast(*this, KeepFlags, !(Options &amp; EGCOptions::Parallel));
    GGCStats.TraceExternalRootsTime += FPlatformTime::Seconds() - StartTime;
  }
PRAGMA_ENABLE_DEPRECATION_WARNINGS
}</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <p>
            <t class="">è¿½è¸ªå¤–éƒ¨ç‰©ä½“ todo</t>
          </p>
          <hr class="divider_block">
          <h3 id="heading3_3">
            <t class="code">PerformReachabilityAnalysisPass</t>
          </h3>
          <p>
            <t class="code">PerformReachabilityAnalysisPass</t>
            <t class=""> æ˜¯è¿™é‡Œçš„æ ¸å¿ƒï¼Œå®ƒåœ¨ä¸€ä¸ª While å¾ªç¯ä¸­è¢«ä½¿ç”¨ï¼Œè¿™ä¸ªå¾ªç¯è¿‡ç¨‹ä¼šé€æ­¥æ ‡è®°æ‰€æœ‰çš„å¯¹è±¡ã€‚ä¸‹é¢æ˜¯å¯¹è¿™ä¸ªå‡½æ•°çš„åˆ†æ­¥è§£æï¼š</t>
          </p>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang rss-ignore">c++</div>
              <pre><code class="language-c++">// GarbageCollection.cpp

void PerformReachabilityAnalysisPass(const EGCOptions Options)
{
  FContextPoolScope Pool;
  FWorkerContext* Context = nullptr;

  if (!GReachabilityState.IsSuspended())
  {
    Context = Pool.AllocateFromPool();
  }
  else
  {
    Context = GReachabilityState.GetContextArray()[0];
    Context-&gt;bDidWork = false;
    InitialObjects.Reset();
  }</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <p>
            <t class="">é¦–å…ˆï¼Œåˆ›å»ºä¸Šä¸‹æ–‡ï¼Œå³ </t>
            <t class="code">FWorkContext</t>
            <t class="">ï¼Œè¿™ä¸ªä¸Šä¸‹æ–‡åŒ…å«äº†æœ¬åœ°çº¿ç¨‹ä¸­çš„åˆå§‹å¯¹è±¡å’Œå¼•ç”¨ä¿¡æ¯ã€‚å¦‚æœå¢é‡å›æ”¶è¢«æš‚åœï¼Œé‚£ä¹ˆç›´æ¥ä½¿ç”¨å¢é‡å›æ”¶çš„ä¸Šä¸€ä¸ªä¸Šä¸‹æ–‡ï¼Œå¦‚æœå¢é‡å›æ”¶æ²¡æœ‰è¢«æš‚åœï¼Œåˆ™ä¼šåˆ›å»ºæ–°çš„å·¥ä½œä¸Šä¸‹æ–‡ã€‚å¦ä¸€ä¸ªä¼šä½¿ç”¨åˆ°çš„é‡è¦å˜é‡ï¼Œæ˜¯ç¼“å­˜çš„å¯è¾¾å¯¹è±¡çš„åˆ—è¡¨ </t>
            <t class="code">GReachableObjects</t>
            <t class="">ï¼ˆä¸‹æ–‡ç§°â€œå¯è¾¾å¯¹è±¡ç¼“å­˜â€ï¼‰ï¼Œè¿™æ˜¯ä¸€ä¸ªé™æ€å¯¹è±¡ï¼Œé‡Œé¢å­˜å‚¨ç€ </t>
            <t class="code">UObject*</t>
            <t class="">ã€‚å®ƒçš„ä½œç”¨æ˜¯ç¼“å­˜å¢é‡åƒåœ¾å›æ”¶æŒ‚èµ·æ—¶æœªè¢«å¤„ç†å®Œçš„å¯¹è±¡ï¼Œå¦‚æœå¢é‡å›æ”¶è¢«æŒ‚èµ·ï¼Œè¿™äº›å¯¹è±¡ä¼šåœ¨ä¸‹ä¸€æ¬¡å¢é‡å›æ”¶ä¸­è¢«å¤„ç†ã€‚</t>
          </p>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang rss-ignore">c++</div>
              <pre><code class="language-c++">  if (!Private::GReachableObjects.IsEmpty())
  {
    // Add objects marked with the GC barrier to the inital set of objects for the next iteration of incremental reachability
    Private::GReachableObjects.PopAllAndEmpty(InitialObjects);
    GGCStats.NumBarrierObjects += InitialObjects.Num();
    UE_LOG(LogGarbage, Verbose, TEXT(&quot;Adding %d object(s) marker by GC barrier to the list of objects to process&quot;), InitialObjects.Num());
    ConditionallyAddBarrierReferencesToHistory(*Context);
  }</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <p>
            <t class="">æ¥ç€ï¼Œå‡½æ•°å°† </t>
            <t class="code">GReachableObjects</t>
            <t class=""> çš„ç¼“å­˜çš„å¯¹è±¡è½¬ç§»åˆ° </t>
            <t class="code">InitialObjects</t>
            <t class=""> ä¸­ï¼Œåœ¨åç»­è¿›è¡Œå¤„ç†ã€‚</t>
          </p>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang rss-ignore">c++</div>
              <pre><code class="language-c++">  else if (GReachabilityState.GetNumIterations() == 0 || (Stats.bFoundGarbageRef &amp;&amp; !GReachabilityState.IsSuspended()))
  {
    Context-&gt;InitialNativeReferences = GetInitialReferences(Options);
  }</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <p>
            <t class="">å¦‚æœå¯è¾¾å¯¹è±¡ç¼“å­˜ä¸ºç©ºï¼Œåˆ™åˆå§‹åŒ–å·¥ä½œä¸Šä¸‹æ–‡ä¸­çš„åˆå§‹å¼•ç”¨ </t>
            <t class="code">InitialNativeRefernces</t>
            <t class="">ã€‚todo</t>
          </p>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang rss-ignore">c++</div>
              <pre><code class="language-c++">  if (!Private::GReachableClusters.IsEmpty())
  {
    // Process cluster roots that were marked as reachable by the GC barrier
    TArray&lt;FUObjectItem*&gt; KeepClusterRefs;
    Private::GReachableClusters.PopAllAndEmpty(KeepClusterRefs);
    for (FUObjectItem* ObjectItem : KeepClusterRefs)
    {
      // Mark referenced clusters and mutable objects as reachable
      MarkReferencedClustersAsReachable&lt;EGCOptions::None&gt;(ObjectItem-&gt;GetClusterIndex(), InitialObjects);
    }
  }</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <p>
            <t class="">åœ¨è¿™é‡Œï¼Œå¯è¾¾é›†ç¾¤ç¼“å­˜ä¼šè¢«å¤„ç†å’Œä¸Šé¢çš„å¯è¾¾å¯¹è±¡ç¼“å­˜ç±»ä¼¼ï¼ˆtodoï¼‰ã€‚åœ¨ä¸Šé¢è¿™æ®µä»£ç ä¸­ä¼šå°†æ‰€æœ‰çš„å¯è¾¾é›†ç¾¤æ‰€å¼•ç”¨çš„é›†ç¾¤æ ‡è®°ä¸ºå¯è¾¾ã€‚</t>
          </p>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang rss-ignore">c++</div>
              <pre><code class="language-c++">  Context-&gt;SetInitialObjectsUnpadded(InitialObjects);</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <p>
            <t class="">todo!</t>
          </p>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang rss-ignore">c++</div>
              <pre><code class="language-c++">  PerformReachabilityAnalysisOnObjects(Context, Options);</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <p>
            <t class="">è¿™ä¸ªå‡½æ•°æ˜¯å¯è¾¾æ€§åˆ†æçš„é‡ç‚¹ï¼Œå®ƒä¼šæ ¹æ®å½“å‰çš„é…ç½®è°ƒç”¨å¯è¾¾æ€§åˆ†æå‡½æ•°ï¼š
</t>
            <t class="code">(this-&gt;*ReachabilityAnalysisFunctions[GetGCFunctionIndex(Options)])(*Context);</t>
          </p>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang rss-ignore">c++</div>
              <pre><code class="language-c++">  if (!GReachabilityState.IsSuspended())
  {
    GReachabilityState.ResetWorkers();
    Stats.AddStats(Context-&gt;Stats);
    GReachabilityState.UpdateStats(Context-&gt;Stats);
    Pool.ReturnToPool(Context);
  }
}</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <p>
            <t class="">æœ€åï¼Œå¦‚æœå¢é‡å›æ”¶æœªè¢«æŒ‚èµ·ï¼Œé‚£ä¹ˆè¿›è¡Œå¢é‡å›æ”¶çš„æ”¶å°¾å·¥ä½œã€‚todo!</t>
          </p>
          <ul>
            <li>
              <t class="">é‡ç½®å·¥ä½œçº¿ç¨‹</t>
            </li>
            <li>
              <t class="">åˆå¹¶ç»Ÿè®¡ä¿¡æ¯</t>
            </li>
            <li>
              <t class="">å½’è¿˜ä¸Šä¸‹æ–‡åˆ°å¯¹è±¡æ± </t>
            </li>
          </ul>
          <h3 id="heading3_4">
            <t class="">æ¸…é™¤åƒåœ¾</t>
          </h3>
          <p>
            <t class="code">TryCollectGarbage/PostCollectGarbageImpl()</t>
          </p>
          <p>
            <t class="">æ¸…é™¤åƒåœ¾çš„è¿‡ç¨‹ä¸»è¦å‘ç”Ÿåœ¨ </t>
            <t class="code">PostCollectGarbageImpl()</t>
            <t class=""> å‡½æ•°ä¸­ã€‚å…¶ä¸»è¦è´Ÿè´£æ¸…ç†æ ‡è®°çš„ä¸å¯è¾¾å¯¹è±¡ã€‚</t>
          </p>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang rss-ignore">c++</div>
              <pre><code class="language-c++">template&lt;bool bPerformFullPurge&gt;
void PostCollectGarbageImpl(EObjectFlags KeepFlags)
{
  const double PostCollectStartTime = FPlatformTime::Seconds();

  using namespace UE::GC;
  using namespace UE::GC::Private;

  if (!GIsIncrementalReachabilityPending)
  {
    FContextPoolScope ContextPool;
    TConstArrayView&lt;TUniquePtr&lt;FWorkerContext&gt;&gt; AllContexts = ContextPool.PeekFree();
    // This needs to happen before clusters get dissolved otherwisise cluster information will be missing from history
    UpdateGCHistory(AllContexts);

    // Reconstruct clusters if needed
    if (GUObjectClusters.ClustersNeedDissolving())
    {
      const double StartTime = FPlatformTime::Seconds();
      GUObjectClusters.DissolveClusters();
      UE_LOG(LogGarbage, Log, TEXT(&quot;%f ms for dissolving GC clusters&quot;), (FPlatformTime::Seconds() - StartTime) * 1000);
    }

    DumpGarbageReferencers(AllContexts);

    const EGatherOptions GatherOptions = GetObjectGatherOptions();
    DissolveUnreachableClusters(GatherOptions);</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <p>
            <t class="">ä¸Šé¢è¿™æ®µé€»è¾‘ä¸»è¦è´Ÿè´£è§£å¼€ä¸å¯è¾¾çš„å¯¹è±¡ç°‡ï¼Œè¿™é‡Œä¸æ·±å…¥ä»‹ç»ã€‚</t>
          </p>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang rss-ignore">c++</div>
              <pre><code class="language-c++">    // This needs to happen after DissolveUnreachableClusters since it can mark more objects as unreachable
    if (GReachabilityState.GetNumIterations() &gt; 1){
      ClearWeakReferences&lt;true&gt;(AllContexts);
    } else {
      ClearWeakReferences&lt;false&gt;(AllContexts);
    }
    if (bPerformFullPurge) {
      ContextPool.Cleanup();
    }
    GGatherUnreachableObjectsState.Init();
    if (bPerformFullPurge || !GAllowIncrementalGather || !FGCFlags::IsIncrementalGatherUnreachableSupported()) {
      GatherUnreachableObjects(GatherOptions, /*TimeLimit =*/ 0.0);
    }
  }</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <p>
            <t class="">æ ‡è®°å¯¹è±¡ä¸ºä¸å¯è¾¾å¹¶æ·»åŠ åˆ° </t>
            <t class="code">GUnreachableObjects</t>
            <t class=""> ä¸­ã€‚</t>
          </p>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang rss-ignore">c++</div>
              <pre><code class="language-c++">  GIsGarbageCollectingAndLockingUObjectHashTables = false;
  UnlockUObjectHashTables();

  GIsGarbageCollecting = false;

  // The hash tables lock was released when reachability analysis was done.
  // BeginDestroy, FinishDestroy, destructors and callbacks are allowed to call functions like StaticAllocateObject and StaticFindObject.
  // Now release the GC lock to allow async loading and other threads to perform UObject operations under the FGCScopeGuard.
  ReleaseGCLock();</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <p>
            <t class="">è‡³æ­¤ï¼Œå¯è¾¾æ€§åˆ†ææ‰å…¨éƒ¨å®Œæˆã€‚ä¸Šé¢çš„è¿‡ç¨‹éƒ½åœ¨ä¸» GC çº¿ç¨‹ä¸­å®Œæˆï¼Œæ­¤å¤„å°† GC çš„é”é‡Šæ”¾ï¼Œä¾›åé¢çš„å·¥ä½œå¹¶è¡Œæ‰§è¡Œã€‚</t>
          </p>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang rss-ignore">c++</div>
              <pre><code class="language-c++">  if (!GIsIncrementalReachabilityPending)
  {
    ...
    // Perform a full purge by not using a time limit for the incremental purge.
    if (bPerformFullPurge)
    {
      IncrementalPurgeGarbage(false);
    }
    ...
  }

  //... log and trace
}</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <p>
            <t class="">è¿™é‡Œçœç•¥äº†å¤§éƒ¨åˆ†ä»£ç ï¼Œç•™ä¸‹äº†æ ¸å¿ƒçš„éƒ¨åˆ†ã€‚</t>
          </p>
          <ul>
            <li>
              <t class="code">IncrementalPurgeGarbage()</t>
              <t class=""> å‡½æ•°æ˜¯å›æ”¶å†…å­˜çš„æ ¸å¿ƒå‡½æ•°ï¼Œåœ¨ </t>
              <t class="code">PostCollectGarbageImpl</t>
              <t class=""> ä¸­åªä¼šè¿›è¡Œå…¨é‡å›æ”¶ã€‚ä½†æ˜¯è¿™ä¸ªå‡½æ•°ä¹Ÿä¼šåœ¨</t>
              <t class="code">UEngine::ConditionalCollectGarbage()</t>
              <t class=""> ä¸­è¢«è°ƒç”¨</t>
            </li>
          </ul>
          <h3 id="heading3_5">
            <t class="code">GatherUnreachableObjects</t>
          </h3>
          <p>
            <t class="code">GatherUnreachableObjects</t>
            <t class=""> ä¼šå¹¶è¡Œåœ°éå†æ‰€æœ‰å¯¹è±¡ï¼Œåˆ¤æ–­å…¶å¯è¾¾æ€§ï¼Œæ ¸å¿ƒä»£ç å¦‚ä¸‹ï¼š</t>
          </p>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang rss-ignore">c++</div>
              <pre><code class="language-c++">while (Iterator.Index &lt;= Iterator.LastIndex)
{
  FUObjectItem* ObjectItem = &amp;GUObjectArray.GetObjectItemArrayUnsafe()[Iterator.Index++];
  if (FGCFlags::IsMaybeUnreachable_ForGC(ObjectItem))
  {
    checkf(!ObjectItem-&gt;HasAnyFlags(EInternalObjectFlags::ClusterRoot), TEXT(&quot;Unreachable cluster root found. Unreachable clusters should have been dissolved in DissolveUnreachableClusters!&quot;));
    FGCFlags::SetUnreachable(ObjectItem);
    Iterator.Payload.Add({ ObjectItem });
  }

  if (Timer.IsTimeLimitExceeded())
  {
    return;
  }
}</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <ul>
            <li>
              <t class="code">FGCFlags::IsMaybeUnreachable_ForGC</t>
              <t class=""> æ£€æŸ¥å¯¹è±¡æ˜¯å¦æœ‰ </t>
              <t class="code">MaybeUnreachableObjectFlag</t>
            </li>
            <li>
              <t class="code">Iterator.Payload.Add({ ObjectItem })</t>
              <t class=""> å°†ä¸å¯è¾¾å¯¹è±¡æ·»åŠ åˆ°ä¸€ä¸ªä¸´æ—¶é›†åˆï¼Œåœ¨åç»­ä½¿ç”¨</t>
            </li>
          </ul>
          <p>
            <t class="">æ¯ä¸ªçº¿ç¨‹çš„è¿­ä»£å™¨é¢„å…ˆè¢«åˆ†é…å¥½ï¼Œç„¶åè¢«è¿­ä»£ã€‚</t>
            <t class="code">FUObjectItem</t>
            <t class=""> é™¤äº†åŒ…å«äº†ä¸€ä¸ª </t>
            <t class="code">UObjectBase*</t>
            <t class=""> è£¸æŒ‡é’ˆå¤–ï¼Œè¿˜å­˜å‚¨äº†ä¸€ä¸ª </t>
            <t class="code">FGCFlags</t>
            <t class=""> ä½æ ‡è®°ã€‚ä¸€ä¸ªä¸å¯è¾¾çš„å¯¹è±¡å°†ä¼šè¢«æ‰“ä¸Š </t>
            <t class="code">EInternalObjectFlags::Unreachabl</t>
            <t class=""> çš„æ ‡è®°ã€‚</t>
          </p>
          <h3 id="heading3_6">
            <t class="code">IncrementalDestroyGarbage</t>
          </h3>
          <p>
            <t class="">åœ¨ </t>
            <t class="code">IncrementalPurgeGarbage</t>
            <t class=""> çš„å‡½æ•°ä¸­è¿™ä¸ªå‡½æ•°çš„æ ¸å¿ƒéƒ¨åˆ†å¦‚ä¸‹ã€‚</t>
          </p>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang rss-ignore">c++</div>
              <pre><code class="language-c++">    if (IsIncrementalUnhashPending())
    {
      bTimeLimitReached = UnhashUnreachableObjects(bUseTimeLimit, TimeLimit);

      if (GUnrechableObjectIndex &gt;= GUnreachableObjects.Num())
      {
        FScopedCBDProfile::DumpProfile();
      }
    }

    if (!bTimeLimitReached)
    {
      bCompleted = IncrementalDestroyGarbage(bUseTimeLimit, TimeLimit);
    }</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <p>
            <t class="">åœ¨è¿™æ®µå¾…ä»£ç ä¸­ï¼Œå¼•æ“ä¼šè°ƒç”¨ </t>
            <t class="code">UnhashUnreachableObjects()</t>
            <t class=""> å‡½æ•°ï¼Œè¿™ä¸ªå‡½æ•°çš„ä¸»è¦åŠŸèƒ½æ˜¯</t>
          </p>
          <ul>
            <li>
              <t class="">å°†ä¸å¯è¾¾å¯¹è±¡ä»å…¨å±€å“ˆå¸Œè¡¨åˆ é™¤ã€‚å…¨å±€å“ˆå¸Œè¡¨ç”¨äºå¿«é€Ÿå®šä½å¯¹è±¡å¦‚ </t>
              <t class="code">StaticFindObject</t>
              <t class="">ï¼›ä¹Ÿç”¨äºæŒ‰è·¯å¾„ç´¢å¼•èµ„æº</t>
            </li>
            <li>
              <t class="">æ‰§è¡Œæ‰€æœ‰ä¸å¯è¾¾å¯¹è±¡çš„</t>
              <t class="code">BeginDestroy()</t>
              <t class=""> å‡½æ•°</t>
            </li>
            <li>
              <t class="">è¿”å›ä¸€ä¸ªæ˜¯å¦è¶…æ—¶çš„å¸ƒå°”å€¼</t>
            </li>
          </ul>
          <p>
            <t class="">å¦‚æœè°ƒç”¨å®Œ </t>
            <t class="code">BeginDestory()</t>
            <t class=""> å·²ç»è¶…æ—¶äº†ï¼Œé‚£ä¹ˆå‰©ä¸‹çš„éƒ¨åˆ†ä¼šåˆ°ä¸‹å¸§æ‰§è¡Œã€‚æ¥ç€ï¼Œè¯¥å‡½æ•°æœ€ç»ˆä¼šè°ƒç”¨ </t>
            <t class="code">IncrementalDestroyGarbage()</t>
          </p>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang rss-ignore">c++</div>
              <pre><code class="language-c++">bool IncrementalDestroyGarbage(bool bUseTimeLimit, double TimeLimit)
{
  ...
      while (GObjCurrentPurgeObjectIndex &lt; GUnreachableObjects.Num())
      {
        FUObjectItem* ObjectItem = GUnreachableObjects[GObjCurrentPurgeObjectIndex].ObjectItem;
        checkSlow(ObjectItem);

        check(!FGCFlags::IsReachable_ForGC(ObjectItem) &amp;&amp; FGCFlags::IsMaybeUnreachable_ForGC(ObjectItem));
        if (ObjectItem-&gt;IsUnreachable())
        {
          UObject* Object = static_cast&lt;UObject*&gt;(ObjectItem-&gt;Object);
          // Object should always have had BeginDestroy called on it and never already be destroyed
          check( Object-&gt;HasAnyFlags( RF_BeginDestroyed ) &amp;&amp; !Object-&gt;HasAnyFlags( RF_FinishDestroyed ) );

          // Only proceed with destroying the object if the asynchronous cleanup started by BeginDestroy has finished.
          if(Object-&gt;IsReadyForFinishDestroy())
          {
            UE::GC::GDetailedStats.IncPurgeCount(Object);
            // Send FinishDestroy message.
            Object-&gt;ConditionalFinishDestroy();
          }
          else
          {
            GGCObjectsPendingDestruction.Add(Object);
            GGCObjectsPendingDestructionCount++;
          }
        }</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <p>
            <t class="">è¿™ä¸€éƒ¨åˆ†æ—¨åœ¨éå† </t>
            <t class="code">GUnreachableObjects</t>
            <t class=""> ä¸­çš„æ‰€æœ‰ä¸å¯è¾¾å¯¹è±¡ï¼Œè°ƒç”¨å®ƒä»¬çš„ </t>
            <t class="code">FinishDestory()</t>
            <t class=""> æ–¹æ³•ï¼Œå¦‚æœ </t>
            <t class="code">IsReadyForFinishDestroy()</t>
            <t class=""> ä¸æ»¡è¶³ï¼Œå°±ä¼šè¢«å»¶è¿Ÿå¤„ç†ï¼ˆ</t>
            <t class="code">GGCObjectsPendingDestruction</t>
            <t class="">ï¼‰ã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œæ­¤æ—¶ä¸å°†å¯¹è±¡ä» </t>
            <t class="code">GUnreachableObjects</t>
            <t class=""> ä¸­åˆ é™¤ï¼Œä¹Ÿå¹¶ä¸é‡Šæ”¾å†…å­˜ã€‚å†…å­˜å°†åœ¨æ‰€æœ‰å¯¹è±¡éƒ½æ‰§è¡Œå®Œ </t>
            <t class="code">FinishDestroy</t>
            <t class=""> åè¢«é‡Šæ”¾ã€‚</t>
          </p>
          <ul>
            <li>
              <t class="">Destructionï¼ˆä¸‹æ–‡å†™ä½œâ€œæ¯ç­â€ï¼‰ï¼šæ ¹æ®æºç å¯ä»¥è§‚å¯Ÿåˆ°ï¼ŒDestruction åœ¨è¿™é‡Œçš„è¯­ä¹‰æŒ‡è°ƒç”¨ </t>
              <t class="code">FinishDestroy()</t>
              <t class="">ï¼Œä¸åŒ…å«é‡Šæ”¾å†…å­˜</t>
            </li>
            <li>
              <t class="code">IsReadyForFinishDestroy()</t>
              <t class=""> æ˜¯ä¸€ä¸ª </t>
              <t class="code">UObject</t>
              <t class=""> çš„å…¬å…±è™šå‡½æ•°ï¼Œ</t>
              <t class="code">UObject</t>
              <t class=""> çš„é»˜è®¤å®ç°æ˜¯è¿”å› </t>
              <t class="code">true</t>
              <t class="">ï¼Œé€šå¸¸è¢«è¦†å†™ï¼Œä¾‹å¦‚ </t>
              <t class="code">AActor</t>
              <t class=""> ä¸­ä¼šåœ¨æ¸²æŸ“ç»“æŸæ—¶æ‰ä¸º </t>
              <t class="code">true</t>
            </li>
            <li>
              <t class="code">ConditionalFinishDestroy()</t>
              <t class=""> ä¼šæ‰§è¡Œ </t>
              <t class="code">FinishDestroy()</t>
              <t class=""> å‡½æ•°</t>
            </li>
            <li>
              <t class="code">GGCObjectsPendingDestruction</t>
              <t class=""> ç¼“å­˜äº†å¾…é”€æ¯çš„å¯¹è±¡çš„æŒ‡é’ˆï¼Œè¿™ä¸ªå˜é‡æ˜¯å…¨å±€çš„ï¼Œå¦‚æœå½“å¸§æ²¡æœ‰å¤„ç†å®Œé‡Œé¢çš„å†…å®¹ï¼ˆå¦‚è¶…è¿‡äº†æ—¶é™ï¼‰ï¼Œä¼šåœ¨ä¸‹ä¸€å¸§å¤„ç†ã€‚ä¸‹æ–‡å°†è¿™ä¸ªå¯¹è±¡ç§°ä¸ºâ€œå¾…é”€æ¯å¯¹è±¡æ•°ç»„â€</t>
            </li>
          </ul>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang rss-ignore">c++</div>
              <pre><code class="language-c++">        ++GObjCurrentPurgeObjectIndex;

        // Only check time limit every so often to avoid calling FPlatformTime::Seconds too often.
        const bool bPollTimeLimit = ((TimeLimitTimePollCounter++) % TimeLimitEnforcementGranularityForDestroy == 0);
        if( bUseTimeLimit &amp;&amp; bPollTimeLimit &amp;&amp; ((FPlatformTime::Seconds() - GCStartTime) &gt; TimeLimit) )
        {
          bTimeLimitReached = true;
          break;
        }
      }
    }</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <p>
            <t class="">æ¥ç€ï¼Œå¼•æ“ä¼šæ£€æŸ¥åƒåœ¾å›æ”¶æœ‰æ²¡æœ‰è¶…æ—¶ï¼Œå¦‚æœè¶…æ—¶ï¼Œåˆ™è·³å‡º while å¾ªç¯ã€‚æ­¤æ—¶æ‰€æœ‰åƒåœ¾çš„ </t>
            <t class="code">FinishDestroy()</t>
            <t class=""> å¹¶æ²¡æœ‰è¢«è°ƒç”¨å®Œæˆã€‚ä¸‹é¢ä¼šæœ‰å¾ˆé•¿ä¸€æ®µä»£ç ç”¨æ¥å¤„ç† </t>
            <t class="code">GGCObjectsPendingDestruction</t>
            <t class=""> é‡Œå»¶è¿Ÿå¤„ç†çš„å¯¹è±¡ã€‚</t>
          </p>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang rss-ignore">c++</div>
              <pre><code class="language-c++">    // Have we finished the first round of attempting to call FinishDestroy on unreachable objects?
    if (GObjCurrentPurgeObjectIndex &gt;= GUnreachableObjects.Num())
    {
      ...
      while( GGCObjectsPendingDestructionCount &gt; 0 )
      {
        int32 CurPendingObjIndex = 0;
        while( CurPendingObjIndex &lt; GGCObjectsPendingDestructionCount )
        {
          ...
        }</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <p>
            <t class="">å¤–é¢çš„ while ä¼šè¿›è¡Œå¯¹ </t>
            <t class="code">GGCObjectsPendingDestruction</t>
            <t class=""> è¿›è¡Œä¸æ–­åœ°è½®è¯¢ï¼Œç›´åˆ°è¶…å‡ºæ—¶é—´é™åˆ¶æˆ–å¾…é”€æ¯å¯¹è±¡ä¸ºç©ºï¼Œä¸ºç©ºä»£è¡¨ç€æ‰€æœ‰å·¥ä½œå·²ç»å®Œæˆï¼Œä¼šè¿›å…¥å†…å­˜é‡Šæ”¾é˜¶æ®µã€‚</t>
          </p>
          <p>
            <t class="">åœ¨ä¸€æ¬¡è½®è¯¢ä¸­ï¼Œå†…éƒ¨çš„ while å¾ªç¯é¦–å…ˆä¼šéå†ä¸€é </t>
            <t class="code">GGCObjectsPendingDestruction</t>
            <t class="">ï¼Œå°è¯•å¯¹å…¶è¿›è¡Œæ¯ç­å¹¶ä» </t>
            <t class="code">GGCObjectsPendingDestruction</t>
            <t class=""> ä¸­ç§»é™¤ã€‚å¦‚æœè¿˜æ˜¯ä¸èƒ½æ¯ç­ï¼Œåˆ™æŠŠå®ƒä¿ç•™åœ¨ </t>
            <t class="code">GGCObjectsPendingDestruction</t>
            <t class="">ã€‚ç­‰å¾…ä¸‹ä¸€æ¬¡è½®è¯¢ã€‚</t>
          </p>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang rss-ignore">c++</div>
              <pre><code class="language-c++">        if( bUseTimeLimit )
        {
          break;
        }</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <p>
            <t class="">å¦‚æœè®¾ç½®äº† CG ä¸€å¸§çš„æ—¶é—´é™åˆ¶ï¼Œå¹¶ä¸”æˆ‘ä»¬å·²ç»å¯¹æ‰€æœ‰å‰©ä½™å¯¹è±¡å®Œæˆäº†ä¸€æ¬¡å®Œæ•´çš„è¿­ä»£å¤„ç†ï¼Œé‚£ä¹ˆå³ä½¿è¿˜æœ‰å‰©ä½™æ—¶é—´æˆ–æœªå¤„ç†çš„å¯¹è±¡ï¼Œä¹Ÿç›´æ¥é€€å‡ºå¾ªç¯ã€‚æ­¤æ—¶å¾ˆå¯èƒ½æ˜¯åœ¨ç­‰å¾…æ¸²æŸ“çº¿ç¨‹ï¼ˆå¦‚èµ„æºé‡Šæ”¾ï¼‰ã€‚æ²¡æœ‰å®Œæˆçš„å·¥ä½œä¼šåœ¨ä¸‹ä¸€å¸§ç»§ç»­ã€‚</t>
          </p>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang rss-ignore">c++</div>
              <pre><code class="language-c++">        else if( GGCObjectsPendingDestructionCount &gt; 0 ) {
          if (FPlatformProperties::RequiresCookedData()) {...}
// Sleep before the next pass to give the render thread some time to release fences.
          FPlatformProcess::Sleep( 0 );
        }
        LastLoopObjectsPendingDestructionCount = GGCObjectsPendingDestructionCount;
      }</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <p>
            <t class="">å¦‚æœæ²¡æœ‰è®¾ç½®æ—¶é—´é™åˆ¶ï¼Œå¼•æ“ä¼šåœ¨ä¸€æ¬¡å¾ªç¯çš„ç»“æŸæ£€æŸ¥ä¸€ä¸‹ç”¨æ—¶ï¼Œå¹¶åœ¨è®¤ä¸ºæ—¶é—´è¿‡é•¿çš„æ—¶å€™æ‰“å°æ—¥å¿—ï¼Œæé†’å¼€å‘è€…ã€‚</t>
          </p>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang rss-ignore">c++</div>
              <pre><code class="language-c++">      // Have all objects been destroyed now?
      if( GGCObjectsPendingDestructionCount == 0 )
      {
        ...
// Release memory we used for objects pending destruction, leaving some slack space
        GGCObjectsPendingDestruction.Empty( 256 );
// Destroy has been routed to all objects so it's safe to delete objects now.
        GObjFinishDestroyHasBeenRoutedToAllObjects = true;
        GObjCurrentPurgeObjectIndexNeedsReset = true;
        GWarningTimeOutHasBeenDisplayedGC = false;
      }
    }
  }</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <p>
            <t class="">åœ¨ç¦»å¼€å¾ªç¯åï¼Œä¼šå†æ£€æŸ¥ä¸€æ¬¡æ‰§è¡Œ </t>
            <t class="code">FinishDestroy</t>
            <t class=""> çš„å®ŒæˆçŠ¶æ€ã€‚å¦‚æœå¾…é”€æ¯å¯¹è±¡æ•°ç»„ä¸ä¸ºç©ºï¼Œå®ƒä¼šåœ¨ä¸‹ä¸€å¸§çš„è¿™ä¸ªå‡½æ•°è¢«å¤„ç†ï¼›å¦‚æœä¸ºç©ºï¼Œè¯´æ˜æ‰€æœ‰é”€æ¯å·¥ä½œå®Œæˆäº†ï¼Œå¯ä»¥é‡Šæ”¾å†…å­˜äº†ï¼é‚£ä¹ˆå‡½æ•°ä¼šè®¾ç½® </t>
            <t class="code">GObjFinishDestroyHasBeenRoutedToAllObjects</t>
            <t class=""> ä¸º </t>
            <t class="code">true</t>
            <t class="">ï¼Œè¿™ä¸ªå¸ƒå°”å€¼å¾ˆå¿«å°±ä¼šè¢«ç”¨åˆ°ã€‚è¯·çœ‹æ¥ä¸‹æ¥çš„ä»£ç ï¼Œè¿™éƒ¨åˆ†ä»£ç æ˜¯çœŸæ­£é‡Šæ”¾å†…å­˜çš„åœ°æ–¹ã€‚</t>
          </p>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang rss-ignore">c++</div>
              <pre><code class="language-c++">  if (GObjFinishDestroyHasBeenRoutedToAllObjects &amp;&amp; !bTimeLimitReached)
  {
    ...
    GUObjectPurge.DestroyObjects(bUseTimeLimit, TimeLimit, GCStartTime);
    ...
    if (GUObjectPurge.IsFinished())
    {
      bCompleted = true;
      ...
    }
  }
  //...log</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <p>
            <t class="">æœ¬æ–‡åªä¿ç•™äº†æ ¸å¿ƒè°ƒç”¨ï¼Œè¿™é‡Œçš„æ ¸å¿ƒæ˜¯ </t>
            <t class="code">DestroyObjects()</t>
            <t class=""> å‡½æ•°ï¼Œè¿™ä¸ªå‡½æ•°ä¼šéå† </t>
            <t class="code">GUnreachableObjects</t>
            <t class="">ï¼Œå¹¶é‡Šæ”¾å…¶å†…å­˜ã€‚å†…å­˜é‡Šæ”¾çš„éƒ¨åˆ†åœ¨è¿™é‡Œä¸æ·±å…¥ä»‹ç»ã€‚åœ¨æ‰€æœ‰å¯¹è±¡éƒ½é‡Šæ”¾å®Œåï¼Œ</t>
            <t class="code">bCompleted</t>
            <t class=""> ä¼šè®¾ç½®ä¸º </t>
            <t class="code">true</t>
            <t class="">ï¼Œå¹¶åœ¨æœ€åè¢«è¿”å›ã€‚</t>
          </p>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang rss-ignore">c++</div>
              <pre><code class="language-c++">  return bCompleted;
}</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <p>
            <t class="">è‡³æ­¤ï¼Œå¯¹ </t>
            <t class="code">IncrementalDestroyGarbage()</t>
            <t class=""> å‡½æ•°çš„è§£æå·²ç»ç»“æŸäº†ã€‚è¿™ä¸ªå‡½æ•°çš„ä½œç”¨æ˜¯ </t>
            <t class="code">FinishDestroy()</t>
            <t class=""> å‡½æ•°å’Œé‡Šæ”¾å†…å­˜ã€‚å®ƒé€šè¿‡ä¸€ä¸ª</t>
            <t class="bold">å¾…é”€æ¯å¯¹è±¡æ•°ç»„</t>
            <t class="">æ¥å®ç°å¯¹å·¥ä½œçš„è·¨å¸§ç¼“å­˜ï¼Œä¾æ­¤æ¥å®ç°å¢é‡å›æ”¶ï¼›é€šè¿‡ while å¾ªç¯æ¥ç­‰å¾…æ¯ä¸€ä¸ªå¾…é”€æ¯å¯¹è±¡æ‰§è¡Œå®Œ </t>
            <t class="code">FinishDestroy()</t>
            <t class=""> å‡½æ•°ã€‚</t>
          </p>
          <h2 id="heading2_7">
            <t class="code">UWorld::CleanupActors()</t>
          </h2>
          <p>
            <t class="">åœ¨æ‰§è¡Œ </t>
            <t class="code">TryCollectGarbage</t>
            <t class=""> å </t>
            <t class="code">CleanupActors</t>
            <t class=""> ä¼šè¢«æ‰§è¡Œã€‚å› ä¸º Actor å¾€å¾€æ˜¯é‡‡ç”¨æ‰‹åŠ¨åœ° </t>
            <t class="code">Destroy</t>
            <t class=""> æ¥åˆ é™¤çš„ï¼Œ</t>
            <t class="code">Destroy</t>
            <t class=""> å¹¶ä¸ä¼šå°† Actor çš„å†…å­˜é‡Šæ”¾ï¼Œè€Œæ˜¯ä½†æ˜¯æ ‡è®°ä¸ºå¾…é”€æ¯ï¼Œç­‰å¾…åƒåœ¾å›æ”¶ç³»ç»Ÿæ¥å¤„ç†ã€‚ä¸‹é¢æ˜¯è§¦å‘ </t>
            <t class="code">Destroy()</t>
            <t class=""> ä¼šæ‰§è¡Œçš„äº‹æƒ…ï¼š</t>
          </p>
          <ul>
            <li>
              <t class="">è§¦å‘ </t>
              <t class="code">OnDestroy</t>
              <t class=""> äº‹ä»¶å’Œè“å›¾é€»è¾‘</t>
            </li>
            <li>
              <t class="">æ ‡è®° </t>
              <t class="code">Actor</t>
              <t class=""> ä¸ºå¾…é”€æ¯ï¼ˆåŒ…æ‹¬äº†å°†å…¶ä» </t>
              <t class="code">ULevel</t>
              <t class=""> çš„ Actor æ•°ç»„ä¸­è®¾ç½®ä¸º </t>
              <t class="code">nullptr</t>
              <t class=""> ç­‰ï¼Œ</t>
              <t class="code">MarkAsGarbage()</t>
              <t class=""> ç­‰ï¼‰</t>
            </li>
            <li>
              <t class="">ä»æ¸¸æˆé€»è¾‘ä¸­ç§»é™¤ï¼Œä¸å‚ä¸æ¸²æŸ“ã€ç‰©ç†è®¡ç®—</t>
            </li>
          </ul>
          <p>
            <t class="">ä½¿ç”¨ </t>
            <t class="code">MarkAsGarbage()</t>
            <t class=""> å°†ä¸€ä¸ª </t>
            <t class="code">UObjectBaseUtility</t>
            <t class="">ï¼ˆ</t>
            <t class="code">UObject</t>
            <t class=""> çš„åŸºç±»ï¼‰ æ ‡è®°ä¸ºåƒåœ¾ã€‚ è¿™ä¸ªå‡½æ•°ä¼šä¸ºè¿™ä¸ªå¯¹è±¡æ·»åŠ ä¸€ä¸ªåä¸º </t>
            <t class="code">RF_MirroredGarbage</t>
            <t class=""> çš„ </t>
            <t class="code">Flag</t>
            <t class="">ã€‚
ç›´æ¥æ£€æŸ¥ä¸€ä¸ª </t>
            <t class="code">UObjet</t>
            <t class=""> æ˜¯å¦åƒåœ¾çš„åŠæ³•æ˜¯ä½¿ç”¨ </t>
            <t class="code">IsValidChecked()</t>
            <t class=""> å‡½æ•°ï¼Œè¿™ä¸ªå‡½æ•°å®é™…ä¸Šä¼šæ£€æŸ¥ </t>
            <t class="code">Flag</t>
            <t class="">ï¼Œè¿”å› </t>
            <t class="code">false</t>
            <t class=""> æ„å‘³ç€è¿™ä¸ªå¯¹è±¡æ˜¯åƒåœ¾ã€‚åœ¨åƒåœ¾å›æ”¶æ—¶ï¼Œè¿™æ ·ç›´æ¥è¢«æ ‡è®°ä¸ºåƒåœ¾çš„å¯¹è±¡ä¼šè¢«æ ‡è®°ä¸ºä¸å¯è¾¾ã€‚è¿›è€Œåœ¨åƒåœ¾å›æ”¶æ—¶è¢«é‡Šæ”¾ã€‚</t>
          </p>
          <p>
            <t class="code">CleanupActors</t>
            <t class=""> æ¸…é™¤çš„æ˜¯å…³å¡çš„ Actor åˆ—è¡¨ä¸­çš„ç©ºæŒ‡é’ˆï¼Œè¿‡ç¨‹å¹¶ä¸å¤æ‚ï¼Œæœ¬æ–‡ç›´æ¥ä»¥æ³¨é‡Šçš„æ–¹å¼è§£é‡Šï¼š</t>
          </p>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang rss-ignore">c++</div>
              <pre><code class="language-c++">void UWorld::CleanupActors()
{
  // éå†æ‰€æœ‰ä¸–ç•Œ
  for (ULevel* Level : Levels)
  {
    if(ensure(Level != nullptr) &amp;&amp; (CurrentLevelPendingVisibility != Level))
    {

      const int32 FirstDynamicIndex = 2;
      int32 NumActorsToRemove = 0;
      // åå‘éå† Actorsï¼Œå› ä¸ºä¼šå‘ç”Ÿåˆ é™¤ Actor
      for(int32 ActorIndex=Level-&gt;Actors.Num()-1;
        ActorIndex&gt;=FirstDynamicIndex;
        ActorIndex-- )
      {
        // ä¸ºäº†å‡å°‘å†…å­˜æ“ä½œæ¬¡æ•°ï¼Œåœ¨é‡åˆ°ç©º Actor æ—¶ï¼Œ
        // å¼•æ“ä¼šå¢åŠ ä¸€ä¸ªè¿ç»­ç©º Actor è®¡æ•°ï¼Œå³ä¸Šé¢çš„ NumActorsToRemove
        // åœ¨é‡åˆ°éç©ºå¯¹è±¡çš„æ—¶å€™ï¼Œæ‰ä¼šæŠŠä¹‹å‰é‡åˆ°çš„ä¸€ç³»åˆ—è¿ç»­çš„ç©º Actor åˆ é™¤
        if (Level-&gt;Actors[ActorIndex] == nullptr)
        {
          ++NumActorsToRemove;
        }
        else if (NumActorsToRemove &gt; 0)
        {
          Level-&gt;Actors.RemoveAt(ActorIndex+1, NumActorsToRemove, EAllowShrinking::No);
          NumActorsToRemove = 0;
        }
      }
      if (NumActorsToRemove &gt; 0)
      {
        Level-&gt;Actors.RemoveAt(FirstDynamicIndex, NumActorsToRemove, EAllowShrinking::No);
      }
    }
  }
}</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <h1 id="heading1_4" index-text="V">
            <t class="">å¼•ç”¨ä¸å¯¹è±¡å›¾</t>
          </h1>
          <p>
            <t class="">å¯¹è±¡å›¾ç”±æ‰€æœ‰ </t>
            <t class="code">UObject</t>
            <t class=""> çš„å¼•ç”¨å…³ç³»é€»è¾‘è¡¨ç¤ºï¼Œå¹¶æ²¡æœ‰ä¸€ä¸ªç›´æ¥çš„æ˜¾å¼çš„å¯¹è±¡å›¾æ•°æ®ç»“æ„ã€‚è¿è¡Œæ—¶çš„å¼•ç”¨æ”¶é›†é€»è¾‘å¤§è‡´å¦‚ä¸‹ï¼š</t>
          </p>
          <ul>
            <li>
              <t class="">è‡ªåŠ¨æ”¶é›† </t>
              <t class="code">UPROPERTY</t>
              <t class=""> å¼•ç”¨ï¼Œè¿™éƒ¨åˆ†ä¸»è¦é…åˆåå°„ç³»ç»Ÿå®Œæˆ</t>
            </li>
            <li>
              <t class="">å¯¹äºé </t>
              <t class="code">UPROPERTY</t>
              <t class=""> å¼•ç”¨ï¼Œå¯ä»¥é€šè¿‡ </t>
              <t class="code">UGCObject</t>
              <t class=""> å’Œé‡å†™ </t>
              <t class="code">UObject::AddReferencedObjects</t>
              <t class=""> æ–¹æ³•æ¥æ·»åŠ è‡ªå®šä¹‰å¼•ç”¨æ·»åŠ è¡Œä¸ºï¼ˆè¯¥å‡½æ•°é»˜è®¤åœ¨è¿è¡Œæ—¶æ²¡æœ‰è¡Œä¸ºï¼‰</t>
            </li>
          </ul>
          <p>
            <t class="">ç‰¹æ®Šåè¯
</t>
            <t class="code">ARO</t>
            <t class="">ï¼š</t>
            <t class="code">AddReferencedObjects</t>
            <t class=""> çš„ç®€å†™</t>
          </p>
          <h2 id="heading2_8">
            <t class="">è‡ªåŠ¨å¼•ç”¨ç”Ÿæˆä¸éå†</t>
          </h2>
          <p>
            <t class="">åœ¨ä¸Šä¸€ç« ï¼Œæˆ‘ä»¬å·²ç»çŸ¥é“ï¼Œè¿›è¡Œå¯è¾¾æ€§åˆ†æçš„è¿‡ç¨‹å‘ç”Ÿåœ¨ </t>
            <t class="code">ReachabilityAnalysisFunctions[]</t>
            <t class=""> ä¸­ã€‚è¿™ä¸ªæ•°ç»„å­˜å‚¨çš„æ˜¯å‡½æ•°æŒ‡é’ˆã€‚</t>
          </p>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang rss-ignore">c++</div>
              <pre><code class="language-c++">  typedef void(FRealtimeGC::*ReachabilityAnalysisFn)(FWorkerContext&amp;);

  /** Pointers to functions used for Reachability Analysis */
  ReachabilityAnalysisFn ReachabilityAnalysisFunctions[8];</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <p>
            <t class="">è¿™ä¸ªå‡½æ•°æŒ‡é’ˆçš„æ•°ç»„åœ¨ </t>
            <t class="code">FRealtimeGC</t>
            <t class=""> çš„æ„é€ å‡½æ•°ä¸­è¢«åˆå§‹åŒ–ï¼Œè¿™é‡Œå±•ç¤º </t>
            <t class="code">EGCOptions::None</t>
            <t class=""> çš„åˆå§‹åŒ–ä»£ç ï¼š</t>
          </p>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang rss-ignore">c++</div>
              <pre><code class="language-c++">FRealtimeGC()
{
  ReachabilityAnalysisFunctions[GetGCFunctionIndex(EGCOptions::None)] = &amp;FRealtimeGC::PerformReachabilityAnalysisOnObjectsInternal&lt;EGCOptions::None | EGCOptions::None&gt;;
  ...
}</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <p>
            <t class="">å®é™…ä¸Šï¼Œæ‰€æœ‰ </t>
            <t class="code">EGCOptions</t>
            <t class=""> çš„å˜ä½“æ‰§è¡Œçš„éƒ½æ˜¯ </t>
            <t class="code">FRealtimeGC::PerformReachabilityAnalysisOnObjectsInternal</t>
            <t class=""> å‡½æ•°ï¼Œåªæ˜¯å®ƒä»¬è¢«ä¼ å…¥äº†ä¸åŒçš„æ¨¡æ¿å‚æ•°ã€‚å¯ä»¥è¯´ï¼Œ</t>
            <t class="code">FRealtimeGC::PerformReachabilityAnalysisOnObjectsInternal</t>
            <t class=""> æ˜¯å¯è¾¾æ€§åˆ†æçš„èµ·ç‚¹ã€‚ä¸‹é¢æ˜¯å®ƒçš„ä»£ç ï¼š</t>
          </p>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang rss-ignore">c++</div>
              <pre><code class="language-c++">  template &lt;EGCOptions Options&gt;
  void PerformReachabilityAnalysisOnObjectsInternal(FWorkerContext&amp; Context)
  {
    TRACE_CPUPROFILER_EVENT_SCOPE(PerformReachabilityAnalysisOnObjectsInternal);
    //... Editor Only
    TReachabilityProcessor&lt;Options&gt; Processor;
    CollectReferencesForGC&lt;TReachabilityCollector&lt;Options&gt;&gt;(Processor, Context);
  }</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <ul>
            <li>
              <t class="code">TReachabilityProcessor</t>
              <t class=""> æ˜¯å®ç°å¯è¾¾æ€§åˆ†æçš„æ ¸å¿ƒé€»è¾‘çš„ç±»ï¼Œä¸‹æ–‡ä¸­æˆ‘ä»¬ä¼šå…·ä½“ä»‹ç»ã€‚</t>
            </li>
          </ul>
          <p>
            <t class="">æˆ‘ä»¬æ¥å…·ä½“çœ‹ä¸€çœ‹ </t>
            <t class="code">CollectReferencesForGC</t>
            <t class="">ï¼š</t>
          </p>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang rss-ignore">c++</div>
              <pre><code class="language-c++">template&lt;class CollectorType, class ProcessorType&gt;
FORCEINLINE void CollectReferencesForGC(ProcessorType&amp; Processor, UE::GC::FWorkerContext&amp; Context)
{
    using FastReferenceCollector = TFastReferenceCollector&lt;ProcessorType, CollectorType&gt;;

    if constexpr (IsParallel(ProcessorType::Options))
    {       ProcessAsync([](void* P, FWorkerContext&amp; C) { FastReferenceCollector(*reinterpret_cast&lt;ProcessorType*&gt;(P)).ProcessObjectArray(C); }, &amp;Processor, Context);
    }    else
    {
       if (!GReachabilityState.IsSuspended())
       {          GReachabilityState.SetupWorkers(1);
          GReachabilityState.GetContextArray()[0] = &amp;Context;
       }
       FastReferenceCollector(Processor).ProcessObjectArray(Context);

       Context.ResetInitialObjects();
       Context.InitialNativeReferences = TConstArrayView&lt;UObject**&gt;();

       GReachabilityState.CheckIfAnyContextIsSuspended();
    }}</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <p>
            <t class="">å…¶ä¸­ï¼Œæ‰§è¡Œæ ¸å¿ƒé€»è¾‘æ˜¯è¿™å¥ï¼š</t>
          </p>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang rss-ignore">c++</div>
              <pre><code class="language-c++">FastReferenceCollector(Processor).ProcessObjectArray(Context);</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <p>
            <t class="code">ProcessObjectArray()</t>
            <t class=""> å‡½æ•°çš„ä½œç”¨æ˜¯é€’å½’åœ°éå†å¯¹è±¡å¼•ç”¨é“¾ï¼Œæ ‡è®°æ‰€æœ‰å¯è¾¾å¯¹è±¡ã€‚ä¸‹é¢æ˜¯å¯¹å®ƒçš„å…·ä½“åˆ†æï¼š</t>
          </p>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang rss-ignore">c++</div>
              <pre><code class="language-c++">  void ProcessObjectArray(FWorkerContext&amp; Context)
  {
    Context.bDidWork = true;
    Context.bIsSuspended = false;
    static_assert(!EnumHasAllFlags(Options, EGCOptions::Parallel | EGCOptions::AutogenerateSchemas), &quot;Can't assemble token streams in parallel&quot;);

    CollectorType Collector(Processor, Context);

    // Either TDirectDispatcher living on the stack or TBatchDispatcher reference owned by Collector
    decltype(GetDispatcher(Collector, Processor, Context)) Dispatcher = GetDispatcher(Collector, Processor, Context);</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <p>
            <t class="">é¦–å…ˆå‡½æ•°ä¼šåˆå§‹åŒ–å·¥ä½œä¸Šä¸‹æ–‡ï¼ŒåŒæ—¶åˆ›å»ºæ”¶é›†å™¨å’Œåˆ†å‘å™¨ï¼š</t>
          </p>
          <ul>
            <li>
              <t class="">æ”¶é›†å™¨ï¼ˆ</t>
              <t class="code">Collector</t>
              <t class="">ï¼‰è´Ÿè´£æ”¶é›†å¼•ç”¨</t>
            </li>
            <li>
              <t class="">åˆ†å‘å™¨ï¼ˆ</t>
              <t class="code">Dispatcher</t>
              <t class="">ï¼‰æ ¹æ®ï¼ˆå•/å¤šçº¿ç¨‹ï¼‰é€‰æ‹©ä»»åŠ¡åˆ†å‘ç­–ç•¥ï¼Œå¯¹å½“å‰å·¥ä½œç‰©ä½“ä»¬è¿›è¡Œä¸€æ¬¡å¼•ç”¨éå†æ­¥è¿›ï¼ˆProcessï¼‰å¾—åˆ°çš„å¼•ç”¨é¦–å…ˆä¼šå­˜å‚¨åœ¨åˆ†å‘å™¨ä¸­ï¼Œæ¥ç€ä¼šé€šè¿‡å—ï¼ˆBlockï¼‰çš„æ–¹å¼åˆ†å‘ç»™å„ä¸ªçº¿ç¨‹å…·ä½“ï¼Œä¸‹æ–‡ä¼šè¯¦ç»†è®²è¿°è¿™ä¸ªè¿‡ç¨‹</t>
            </li>
          </ul>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang rss-ignore">c++</div>
              <pre><code class="language-c++">StoleContext:
    // Process initial references first
    Context.ReferencingObject = FGCObject::GGCObjectReferencer;
    for (UObject** InitialReference : Context.InitialNativeReferences)
    {
      Dispatcher.HandleKillableReference(*InitialReference, EMemberlessId::InitialReference, EOrigin::Other);
    }
    TConstArrayView&lt;UObject*&gt; CurrentObjects = Context.InitialObjects;</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <p>
            <t class="">è¿™æ®µä»£ç çš„å·¥ä½œæ˜¯ä»ä¸Šä¸‹æ–‡è·å¾—æ ¹å¯¹è±¡</t>
          </p>
          <ul>
            <li>
              <t class="code">FGCObject::GGCObjectReferencer</t>
              <t class=""> æ˜¯å…¨å±€çš„æ ¹å¼•å¯¹è±¡å¼•ç”¨ç®¡ç†å™¨</t>
            </li>
          </ul>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang rss-ignore">c++</div>
              <pre><code class="language-c++">    while (true)
    {
      Context.Stats.AddObjects(CurrentObjects.Num());
      ProcessObjects(Dispatcher, CurrentObjects);</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <ul>
            <li>
              <t class="code">CurrentObjects</t>
              <t class=""> æ˜¯ä¸€ä¸ª UObject æŒ‡é’ˆçš„æ•°ç»„ï¼Œå­˜å‚¨ç€å½“å‰çš„å¾…å¤„ç†çš„å¯¹è±¡</t>
            </li>
            <li>
              <t class="code">ProcessObjects</t>
              <t class=""> å°±æ˜¯éå†å¯¹è±¡çš„å¼•ç”¨çš„åœ°æ–¹ï¼Œå®ƒä¼šå°†éå†åˆ°å¼•ç”¨æš‚æ—¶å­˜å‚¨åœ¨åˆ†å‘å™¨ </t>
              <t class="code">Dispatcher</t>
              <t class=""> ä¸­ï¼Œæœ¬æ–‡ä¼šåœ¨ä¹‹åä¼šå…·ä½“ä»‹ç»è¿™ä¸ªå‡½æ•°ï¼Œåœ¨æ­¤å¯ä»¥æš‚æ—¶è®¤ä¸ºæˆ‘ä»¬å·²ç»å¾—åˆ°äº†å½“å‰å¯¹è±¡çš„å¼•ç”¨å…³ç³»åœ¨åˆ†å‘å™¨ä¸­</t>
            </li>
          </ul>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang rss-ignore">c++</div>
              <pre><code class="language-c++">      // Free finished work block
      if (CurrentObjects.GetData() != Context.InitialObjects.GetData())
      {
        Context.ObjectsToSerialize.FreeOwningBlock(CurrentObjects.GetData());
      }</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <p>
            <t class="">éå†å®Œ </t>
            <t class="code">CurrentObjects</t>
            <t class=""> åï¼Œå®ƒå…¶å®å·²ç»ä¸è¢«éœ€è¦äº†ï¼Œæ‰€ä»¥åœ¨è¿™é‡Œå°±å°†å®ƒé‡Šæ”¾æ‰ã€‚ï¼ˆå½“ç„¶ï¼Œåˆå§‹å¯¹è±¡åˆ—è¡¨æ˜¯ä¸èƒ½é‡Šæ”¾çš„ï¼Œæ‰€ä»¥è¦è¿›è¡Œä¸€ä¸ªæ¡ä»¶åˆ¤æ–­ï¼‰</t>
          </p>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang rss-ignore">c++</div>
              <pre><code class="language-c++">      if (Processor.IsTimeLimitExceeded())
      {
        FlushWork(Dispatcher);
        Dispatcher.Suspend();
        SuspendWork(Context);
        return;
      }</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <p>
            <t class="">è¿™æ®µä»£ç çš„ä½œç”¨æ˜¯ï¼Œæ£€æŸ¥æ˜¯å¦è¶…è¿‡å¢é‡å›æ”¶çš„ä¸€å¸§çš„æ—¶é—´é¢„ç®—ã€‚å¦‚æœå·²ç»è¶…æ—¶äº†ï¼Œå°±æš‚åœå›æ”¶ï¼Œåœ¨ä¸‹ä¸€å¸§ç»§ç»­å›æ”¶ã€‚</t>
          </p>
          <ul>
            <li>
              <t class="code">Processor.IsTimeLimitExceeded()</t>
              <t class=""> æ£€æŸ¥æ˜¯å¦è¶…è¿‡å¢é‡å¼å›æ”¶çš„æ¯å¸§é¢„ç®—</t>
            </li>
            <li>
              <t class="code">FlushWork</t>
              <t class=""> å°† </t>
              <t class="code">Dispatcher</t>
              <t class=""> ä¸­çš„å·¥ä½œè½¬ç§»å‡ºæ¥ï¼Œæš‚å­˜åˆ° </t>
              <t class="code">TFastReferenceCollector</t>
              <t class=""> ä¸­</t>
            </li>
          </ul>
          <p>
            <t class="">åˆ°æ­¤ï¼Œä¸€æ¬¡éå†æ­¥è¿›çš„å·¥ä½œå·²ç»å®Œæˆäº†ï¼Œä¹‹åçš„ä»£ç æ˜¯åˆ†é…æ–°çš„éå†å·¥ä½œã€‚åˆ†é…çš„æ–¹å¼æ˜¯ä»¥å·¥ä½œå— </t>
            <t class="code">FWorkBlock</t>
            <t class=""> ä¸ºå•ä½çš„ã€‚</t>
          </p>
          <ul>
            <li>
              <t class="code">FWorkBlock</t>
              <t class=""> æ˜¯ä¸€ç»„å›ºå®šæ•°é‡çš„å¯¹è±¡çš„é›†åˆã€‚åˆ†å—ç›®çš„æ˜¯å°†å¯è¾¾æ€§åˆ†æçš„ä»»åŠ¡åˆ†å‰²æˆå¤šä¸ªå¿«ï¼Œæœ‰åŠ©äºå¹¶è¡Œä¼˜åŒ–å’Œå¢é‡å¼å›æ”¶ï¼›åŒæ—¶ </t>
              <t class="code">FWorkBlock</t>
              <t class=""> è¢«è®¾è®¡æˆç¼“å­˜å‹å¥½çš„æ•°æ®ç»“æ„ï¼Œæœ‰å¾ˆå¥½çš„æ€§èƒ½è¡¨ç°ã€‚</t>
            </li>
          </ul>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang rss-ignore">c++</div>
              <pre><code class="language-c++">      int32 BlockSize = FWorkBlock::ObjectCapacity;
      FWorkBlockifier&amp; RemainingObjects = Context.ObjectsToSerialize;
      FWorkBlock* Block = RemainingObjects.PopFullBlock&lt;Options&gt;();</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <p>
            <t class="">è¿™æ®µä»£ç å°±æ˜¯å°†å½“å‰çš„å¾…å¤„ç†å¯¹è±¡ä¸­è·å–ä¸€ä¸ªå®Œæ•´å¤§å°çš„å·¥ä½œå—ï¼ˆ</t>
            <t class="code">FWorkBlock</t>
            <t class="">ï¼‰ï¼Œå¦‚æœæ— æ³•è·å–ä¸€ä¸ªå®Œæ•´çš„å·¥ä½œå—ï¼ˆå¾…å¤„ç†æ•°é‡å¤§äºå·¥ä½œå—å®¹é‡ï¼‰ï¼Œåˆ™è¿›è¡Œæ›´ç»†è‡´çš„å·¥ä½œåˆ†é…ï¼š</t>
          </p>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang rss-ignore">c++</div>
              <pre><code class="language-c++">      if (!Block)
      {
        if constexpr (bIsParallel)
        {
          FSlowARO::ProcessUnbalancedCalls(Context, Collector);
        }

StoleARO:
        FlushWork(Dispatcher);</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <p>
            <t class="code">FlushWork(Dispatcher)</t>
            <t class=""> ä¼šå°†æœ¬åœ°çº¿ç¨‹çš„ä»»åŠ¡ç»“æœåˆå¹¶åˆ°å…±äº«çš„ </t>
            <t class="code">RemainingObjects</t>
            <t class=""> ä¸­ã€‚  è¿™ä¼šå¢åŠ  </t>
            <t class="code">RemainingObjects</t>
            <t class=""> çš„æ•°é‡ï¼Œç„¶ååœ¨ä¸‹é¢å¼•æ“ä¼šå†å°è¯•è·å–å·¥ä½œå—ï¼š</t>
          </p>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang rss-ignore">c++</div>
              <pre><code class="language-c++">        if (Block = RemainingObjects.PopFullBlock&lt;Options&gt;(); Block);
        else if (Block = RemainingObjects.PopPartialBlock(/* out if successful */ BlockSize); Block);</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <p>
            <t class="">å¦‚æœè¿˜æ˜¯æ— æ³•å–å‡ºä¸€ä¸ªå·¥ä½œå—ï¼Œåˆ™åªå–å‡ºä¸€ä¸ªå·¥ä½œå—ã€‚å¦‚æœä¸€ä¸ªéƒ½å–ä¸å‡ºæ¥ï¼Œè¯´æ˜è¯¥çº¿ç¨‹çš„å·¥ä½œå·²ç»ç»“æŸäº†ã€‚</t>
          </p>
          <ul>
            <li>
              <t class="code">BlockSize</t>
              <t class=""> åœ¨ä¸Šé¢çš„ä»£ç ä¸­å‡ºç°è¿‡ï¼Œæ˜¯ä¸€ä¸ªå·¥ä½œå—çš„å®¹é‡</t>
            </li>
            <li>
              <t class="code">RemainingObjects.PopPartialBlock</t>
              <t class=""> å¿…é¡»æ˜¯åŸå­æ€§çš„ï¼Œå› ä¸ºæœ‰å¤šä¸ªçº¿ç¨‹å¯èƒ½ä¼šè¯·æ±‚è¿›è¡Œæ­¤æ“ä½œ</t>
            </li>
          </ul>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang rss-ignore">c++</div>
              <pre><code class="language-c++">        else if (bIsParallel) // if constexpr yields MSVC unreferenced label warning
        {
          switch (StealWork(/* in-out */ Context, Collector, /* out */ Block, Options))
          {
            case ELoot::Nothing:  break;        // Done, stop working
            case ELoot::Block: break;        // Stole full block, process it
            case ELoot::ARO:  goto StoleARO;    // Stole and made ARO calls that feed into Dispatcher queues and RemainingObjects
            case ELoot::Context:  goto StoleContext;  // Stole initial references and initial objects worker that hasn't started working
          }
        }</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <p>
            <t class="">æ—¢ç„¶è¿™ä¸ªçº¿ç¨‹æ²¡æœ‰äº†å·¥ä½œã€‚</t>
            <t class="code">StealWork()</t>
            <t class=""> å‡½æ•°ä¼šå°è¯•è·å–å…¶å®ƒçº¿ç¨‹æ²¡æœ‰åšå®Œçš„å·¥ä½œï¼Œå®ƒæ ¹æ®å½“å‰ä¸Šä¸‹æ–‡è¿”å›ä¸€ä¸ª </t>
            <t class="code">ELoot</t>
            <t class=""> æšä¸¾ï¼Œè¿™ä¸ªæšä¸¾è¡¨ç¤ºå½“å‰ä»»åŠ¡å¯ä»¥çªƒå–çš„çŠ¶æ€ã€‚</t>
            <t class="code">StealWork()</t>
            <t class="">åŒæ—¶ä¹Ÿä¼šç›´æ¥èµ‹å€¼ä¼ å…¥çš„å·¥ä½œä¸Šä¸‹æ–‡ã€‚</t>
          </p>
          <ul>
            <li>
              <t class="code">Nothing</t>
              <t class="">ï¼šä»€ä¹ˆéƒ½ä¸å¹²ç­‰åˆ°ä¸‹é¢æ‰§è¡Œç»“æŸ</t>
            </li>
            <li>
              <t class="code">Block</t>
              <t class="">ï¼šä¸Šæ–‡ä¸­å·²ç»åˆ¤æ–­è¿‡äº†ï¼ˆå®é™…ä¸Šè¿™ä¸ªçº¿ç¨‹ä¹Ÿä¸ä¼šæ‰§è¡Œåˆ°è¿™é‡Œï¼‰ï¼Œç›´æ¥è·å–ä¸€ä¸ªå®Œæ•´çš„å—ï¼Œåœ¨ä¸‹ä¸€æ¬¡å¾ªç¯å·¥ä½œ</t>
            </li>
            <li>
              <t class="code">ARO (AddReferencedObjects)</t>
              <t class="">ï¼šçªƒå–åˆ°å…¶å®ƒçº¿ç¨‹æœªå¤„ç†çš„æ‰‹åŠ¨å¼•ç”¨å·¥ä½œï¼Œæ­¤æ—¶ </t>
              <t class="code">Block</t>
              <t class=""> å·²ç»è¢«æ›¿æ¢æˆå…¶å®ƒçº¿ç¨‹æœªå¤„ç†çš„å·¥ä½œå—ï¼Œ</t>
              <t class="code">goto</t>
              <t class=""> åˆ°ä¸Šé¢çš„ </t>
              <t class="code">StoleARO</t>
              <t class=""> ç›´æ¥å·¥ä½œå³å¯</t>
            </li>
            <li>
              <t class="code">Context</t>
              <t class="">ï¼šçªƒå–åˆ°å…¶å®ƒçº¿ç¨‹æœªå®Œæˆçš„ä¸Šä¸‹æ–‡ä»»åŠ¡ï¼Œæ­¤æ—¶ä¸Šä¸‹é—® </t>
              <t class="code">Context</t>
              <t class=""> å˜é‡å·²ç»è¢«æ›¿æ¢æˆäº†å…¶å®ƒä¸Šä¸‹æ–‡çš„å·¥ä½œï¼Œ</t>
              <t class="code">goto</t>
              <t class=""> åˆ°ä¸Šé¢çš„ </t>
              <t class="code">StoleContext</t>
              <t class=""> ç›´æ¥å·¥ä½œå³å¯</t>
            </li>
          </ul>
          <p>
            <t class="">å¯ä»¥å‘ç°ï¼Œåˆ©ç”¨ </t>
            <t class="code">goto</t>
            <t class="">ï¼Œä¸€ä¸ªçº¿ç¨‹ä¼šåœ¨è‡ªå·±å·¥ä½œå®Œæˆåï¼Œä¸æ–­æ£€æŸ¥æ˜¯å¦æœ‰å…¶å®ƒæ²¡å®Œæˆçš„å·¥ä½œï¼Œç›´åˆ°æ‰€æœ‰çº¿ç¨‹çš„æ‰€æœ‰å·¥ä½œéƒ½è¢«å®Œæˆï¼Œæ¯ä¸ªçº¿ç¨‹æ‰ä¼šç»“æŸè¿™æ®µä»£ç ã€‚</t>
          </p>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang rss-ignore">c++</div>
              <pre><code class="language-c++">        if (!Block)
        {
          break;
        }
      }</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <p>
            <t class="">Block ä¸ºç©ºæ„å‘³ç€ </t>
            <t class="code">RemainingObjects</t>
            <t class=""> å’Œå…¶å®ƒçº¿ç¨‹éƒ½æ²¡æœ‰å·¥ä½œè¦åšäº†ã€‚æ‰€ä»¥é€€å‡º while å¾ªç¯ï¼Œæ„å‘³éå†ç»“æŸã€‚</t>
          </p>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang rss-ignore">c++</div>
              <pre><code class="language-c++">      CurrentObjects = MakeArrayView(Block-&gt;Objects, BlockSize);
    } // while (true)</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <p>
            <t class="">å¦‚æœå·¥ä½œæ²¡æœ‰ç»“æŸï¼ˆå–å‡ºäº†å·¥ä½œå—ï¼‰ï¼Œåˆ™å°†å½“å‰å·¥ä½œå¯¹è±¡ä»¬è®¾ç½®ä¸ºå·¥ä½œå—ä¸­çš„å¯¹è±¡ã€‚åœ¨ä¸‹æ¬¡å¾ªç¯è¿›è¡Œå·¥ä½œã€‚</t>
          </p>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang rss-ignore">c++</div>
              <pre><code class="language-c++">    Processor.LogDetailedStatsSummary();
  }</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <hr class="divider_block">
          <p>
            <t class="">çœŸæ­£æ‰§è¡Œå¯è¾¾æ€§åˆ†æçš„å‡½æ•°æ˜¯ </t>
            <t class="code">ProcessObjects</t>
            <t class="">ï¼Œåœ¨ä¸Šæ–‡ä¸­ï¼Œå®ƒåœ¨ while å¾ªç¯å†…è¢«å¾ªç¯è°ƒç”¨ï¼Œæˆ‘ä»¬æ¥å…·ä½“çœ‹ä¸€ä¸‹å®ƒçš„å†…å®¹ï¼š</t>
          </p>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang rss-ignore">c++</div>
              <pre><code class="language-c++">FORCEINLINE_DEBUGGABLE void ProcessObjects(DispatcherType&amp; Dispatcher, TConstArrayView&lt;UObject*&gt; CurrentObjects)
{
  for (FPrefetchingObjectIterator It(CurrentObjects); It.HasMore(); It.Advance())
  {
    UObject* CurrentObject = It.GetCurrentObject();
    UClass* Class = CurrentObject-&gt;GetClass();
    UObject* Outer = CurrentObject-&gt;GetOuter();</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <p>
            <t class="">é¦–å…ˆå®ƒä¼šå¯¹åœ¨ for å¾ªç¯ä¸­å¯¹ </t>
            <t class="code">CurrentObjects</t>
            <t class=""> è¿›è¡Œè¿­ä»£ã€‚å¹¶è·å–å¯¹è±¡å’Œå¯¹è±¡çš„ç±»çš„ä¿¡æ¯ã€‚</t>
          </p>
          <ul>
            <li>
              <t class="code">UClass</t>
              <t class=""> æ˜¯åå°„ç±»ï¼Œè®°å½•äº†ä¸€ä¸ªç±»çš„åå°„ä¿¡æ¯ï¼Œåœ¨ä¸‹æ–‡ä¸­è·å–ç±»çš„å¼•ç”¨å…³ç³»æ—¶ä¼šç”¨åˆ°ã€‚</t>
              <t class="code">UClass</t>
              <t class=""> çš„å…ƒæ•°æ®åœ¨ç¼–è¯‘æ—¶ç”Ÿæˆï¼Œè¿è¡Œæ—¶åªè¯»</t>
            </li>
            <li>
              <t class="code">Outer</t>
              <t class=""> å˜é‡æ˜¯å½“å‰å¯¹è±¡æ‰€åœ¨çš„çˆ¶å®¹å™¨ï¼Œåœ¨ UE ä¸­ï¼Œå¯¹è±¡çš„çˆ¶å®¹å™¨åªå­˜åœ¨ä¸€ä¸ªï¼Œè¿™ä¹Ÿæ„å‘³ç€ä¸€ä¸ªå¯¹è±¡æœ‰ä¸€æ¡å”¯ä¸€çš„å¼•ç”¨è·¯å¾„</t>
            </li>
          </ul>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang rss-ignore">c++</div>
              <pre><code class="language-c++">    if (!!(Options &amp; EGCOptions::AutogenerateSchemas) &amp;&amp; !Class-&gt;HasAnyClassFlags(CLASS_TokenStreamAssembled))
    {
      Class-&gt;AssembleReferenceTokenStream();
    }

    FSchemaView Schema = Class-&gt;ReferenceSchema.Get();
    Dispatcher.Context.ReferencingObject = CurrentObject;</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <ul>
            <li>
              <t class="code">FSchemaView</t>
              <t class=""> ç±»æè¿°äº†ä¸€ä¸ªç±»çš„æ‰€æœ‰å¼ºå¼•ç”¨å…³ç³»</t>
            </li>
          </ul>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang rss-ignore">c++</div>
              <pre><code class="language-c++">    // Emit base references
    Dispatcher.HandleImmutableReference(Class, EMemberlessId::Class, EOrigin::Other);
    Dispatcher.HandleImmutableReference(Outer, EMemberlessId::Outer, EOrigin::Other);
#if WITH_EDITOR
    UObject* Package = CurrentObject-&gt;GetExternalPackageInternal();
    Package = Package != CurrentObject ? Package : nullptr;
    Dispatcher.HandleImmutableReference(Package, EMemberlessId::ExternalPackage, EOrigin::Other);
#endif</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <ul>
            <li>
              <t class="code">HandleImmutableReference</t>
              <t class=""> ä¼šåœ¨å†…éƒ¨è°ƒç”¨ </t>
              <t class="code">HandleReferenceDirectly</t>
              <t class="">ï¼Œå®ƒä¼šå°†ç‰©ä½“æŒ‡é’ˆæ¨åˆ° </t>
              <t class="code">ImmutableBatcher</t>
              <t class=""> ä¸­ï¼Œç¡®ä¿ä¸ä¼šè¢«å›æ”¶</t>
            </li>
          </ul>
          <p>
            <t class="">å› ä¸º </t>
            <t class="code">UClass</t>
            <t class=""> å’Œ </t>
            <t class="code">Outer</t>
            <t class=""> éƒ½ç»§æ‰¿è‡ª </t>
            <t class="code">UObject</t>
            <t class="">ï¼Œå®ƒä»¬éƒ½æœ‰è¢«å›æ”¶çš„å¯èƒ½ã€‚ä½†æ˜¯ä¸€ä¸ªå¯¹è±¡å¦‚æœå¯è¾¾ï¼Œé‚£ä¹ˆå…¶çˆ¶å®¹å™¨å’Œå¯¹è±¡å’Œåå°„ä¿¡æ¯ä¸€å®šä¸èƒ½è¢«å›æ”¶ï¼Œæ‰€ä»¥å¼•æ“é€šè¿‡å¢åŠ ä¸å¯å˜å¼•ç”¨çš„æ–¹å¼æ¥å®ç°è¿™ä¸ªæ•ˆæœã€‚</t>
          </p>
          <p>
            <t class="">å¼•æ“ä¹‹æ‰€ä»¥è®©ä¸€ä¸ªåå°„ç±» </t>
            <t class="code">UClass</t>
            <t class=""> ç»§æ‰¿è‡ª </t>
            <t class="code">UObject</t>
            <t class="">ï¼Œå‚ä¸åˆ°åƒåœ¾å›æ”¶ä¸­ï¼Œæ˜¯å› ä¸ºè¿™æ ·å¯ä»¥åŠ¨æ€åŠ è½½å’Œå¸è½½ç±»çš„åå°„ä¿¡æ¯ï¼ˆä»…è“å›¾ç±»ï¼‰ã€‚ä¾‹å¦‚ï¼Œåœ¨ä¸€ä¸ªå…³å¡ä¸­ï¼Œä¸€ä¸ªè“å›¾ç±»å¯èƒ½æ°¸è¿œä¸ä¼šè¢«ä½¿ç”¨ï¼Œé‚£ä¹ˆå°±å¯ä»¥ä¸åŠ è½½ä»¥ä¼˜åŒ–æ€§èƒ½ã€‚æ­¤å¤–ï¼Œå¯¹äºå·²ç»åŠ è½½çš„è“å›¾ç±»åå°„ä¿¡æ¯ï¼Œåœ¨ä½¿ç”¨ç»“æŸåå›ä¹Ÿä¼šè¢«åƒåœ¾å›æ”¶å›æ”¶æ”¶æ‰ã€‚ç›¸å¯¹çš„ï¼Œå¼•æ“ä¹Ÿéœ€è¦æä¾›ä¿æŠ¤æœºåˆ¶æ¥ç¡®ä¿ä¸€ä¸ª </t>
            <t class="code">UClass</t>
            <t class=""> ä¸ä¼šè¢«é”™è¯¯å›æ”¶ã€‚ä¸Šæ–‡æåˆ°çš„å°±æ˜¯å…¶ä¸€ã€‚</t>
          </p>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang rss-ignore">c++</div>
              <pre><code class="language-c++">    if (!Schema.IsEmpty())
    {
      typename DispatcherType::SchemaStackScopeType SchemaStack(Dispatcher.Context, Schema);
      Processor.BeginTimingObject(CurrentObject);
      Private::VisitMembers(Dispatcher, Schema, CurrentObject);
      Processor.UpdateDetailedStats(CurrentObject);
    }}}</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <p>
            <t class="">æ¥ä¸‹æ¥è¿™æ®µä»£ç ä¸­ï¼Œåˆ¤æ–­å¦‚æœè¿™ä¸ªç±»ç›¸å…³çš„å¯¹è±¡çš„å›¾ä¸æ˜¯ç©ºçš„ï¼Œå°±æ‰§è¡Œéå†çš„é€»è¾‘ã€‚</t>
          </p>
          <ul>
            <li>
              <t class="code">BeginTimingObject</t>
              <t class=""> å’Œ </t>
              <t class="code">UpdateDetailedStats</t>
              <t class=""> ç”¨äºè®¡æ—¶å’Œæ€§èƒ½åˆ†æ</t>
            </li>
            <li>
              <t class="code">VisitMembers</t>
              <t class=""> æ‰§è¡Œéå†ç±»å›¾çš„åœ°æ–¹ï¼Œå®ƒä¼šå°†ç‰©ä½“æ”¶é›†åˆ° </t>
              <t class="code">Dispatcher</t>
              <t class=""> çš„ </t>
              <t class="code">KillableBatcher</t>
              <t class=""> å’Œ </t>
              <t class="code">ImmutableBatcher</t>
              <t class=""> ä¸­</t>
            </li>
          </ul>
          <p>
            <t class="">ä¸Šæ–‡æåˆ°è¿‡ï¼Œ</t>
            <t class="code">Dispacher</t>
            <t class=""> ä¸­çš„ç‰©ä½“æœ€ç»ˆä¼šè¢«åˆå¹¶åˆ°å·¥ä½œå¯¹è±¡æ•°ç»„ä¸­ã€‚è‡³æ­¤ </t>
            <t class="code">ProcessObjects</t>
            <t class=""> å®Œæˆäº†å®ƒè¿›è¡Œä¸€æ¬¡å¯è¾¾æ€§åˆ†æçš„æ­¥è¿›çš„ä»»åŠ¡ã€‚</t>
          </p>
        </div>
      </div>
      <div class="sidebar_wrapper_right sidebar_wrapper">
        <div class="catalogue">
          <ul>
            <li class="h1"><a href="#heading1_0">
                <t class="">å‰è¨€</t>
              </a></li>
            <li class="h2"><a href="#heading2_0">
                <t class="">åƒåœ¾å›æ”¶æ¦‚å¿µ</t>
              </a></li>
            <li class="h2"><a href="#heading2_0">
                <t class="">ç« èŠ‚å®‰æ’</t>
              </a></li>
            <li class="h1"><a href="#heading1_1">
                <t class="">UE 5 åƒåœ¾å›æ”¶ç¼–ç¨‹èŒƒå¼</t>
              </a></li>
            <li class="h2"><a href="#heading2_0">
                <t class="">å¢é‡å›æ”¶</t>
              </a></li>
            <li class="h2"><a href="#heading2_0">
                <t class="">å¤šçº¿ç¨‹ä¸å¼‚æ­¥ä¼˜åŒ–</t>
              </a></li>
            <li class="h1"><a href="#heading1_2">
                <t class="">åƒåœ¾å›æ”¶çš„è§¦å‘æœºåˆ¶</t>
              </a></li>
            <li class="h2"><a href="#heading2_0">
                <t class="">å¼ºåˆ¶åƒåœ¾å›æ”¶</t>
              </a></li>
            <li class="h2"><a href="#heading2_0">
                <t class="">æ¡ä»¶åƒåœ¾å›æ”¶</t>
              </a></li>
            <li class="h3"><a href="#heading3_0">
                <t class="code">ConditionalCollectGarbage</t>
                <t class=""> è¯¦è§£</t>
              </a></li>
            <li class="h3"><a href="#heading3_1">
                <t class="code">PerformGarbageCollectionAndCleanupActors()</t>
              </a></li>
            <li class="h1"><a href="#heading1_3">
                <t class="">åƒåœ¾å›æ”¶çš„æ‰§è¡Œè¿‡ç¨‹</t>
              </a></li>
            <li class="h2"><a href="#heading2_2">
                <t class="">å›æ”¶è¿‡ç¨‹ï¼š</t>
                <t class="code">TryCollectGarbage</t>
              </a></li>
            <li class="h3"><a href="#heading3_2">
                <t class="">å¯è¾¾æ€§åˆ†æ</t>
              </a></li>
            <li class="h3"><a href="#heading3_3">
                <t class="code">PerformReachabilityAnalysisPass</t>
              </a></li>
            <li class="h3"><a href="#heading3_4">
                <t class="">æ¸…é™¤åƒåœ¾</t>
              </a></li>
            <li class="h3"><a href="#heading3_5">
                <t class="code">GatherUnreachableObjects</t>
              </a></li>
            <li class="h3"><a href="#heading3_6">
                <t class="code">IncrementalDestroyGarbage</t>
              </a></li>
            <li class="h2"><a href="#heading2_7">
                <t class="code">UWorld::CleanupActors()</t>
              </a></li>
            <li class="h1"><a href="#heading1_4">
                <t class="">å¼•ç”¨ä¸å¯¹è±¡å›¾</t>
              </a></li>
            <li class="h2"><a href="#heading2_7">
                <t class="">è‡ªåŠ¨å¼•ç”¨ç”Ÿæˆä¸éå†</t>
              </a></li>
          </ul>
        </div>
      </div>
    </div>
  </body>
</html>

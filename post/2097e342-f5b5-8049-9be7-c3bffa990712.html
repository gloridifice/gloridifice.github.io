<!DOCTYPE html><html>
  <head>
    <meta name="darkreader-lock" content="true">
    <meta http-equiv="Content-Type" content="charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="/assets/js/header.js"></script>
    <script src="/assets/katex/katex.js"></script>
<script defer src="/assets/katex/auto-render.min.js" onload="renderMathInElement(document.body);"></script>    <script>document.addEventListener(&quot;DOMContentLoaded&quot;, function() {
    renderMathInElement(document.body, {
      delimiters: [
          {left: '$$', right: '$$', display: false},
      ],
      throwOnError : false
    });
});</script>
    <link rel="stylesheet" href="/assets/katex/katex.css">
    <link rel="stylesheet" href="/assets/css/reset.css">
    <link rel="stylesheet" href="/assets/css/root.css">
    <link rel="stylesheet" href="/assets/css/color_scheme_v2.dark_mode.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@300;400;600;700&amp;display=swap" rel="stylesheet">
    <script src="/assets/js/highlightjs/highlight.js"></script>
    <link rel="stylesheet" href="/assets/css/layout.css">
    <link rel="stylesheet" href="/assets/css/page_content.css">
    <link rel="stylesheet" href="/assets/css/post.css">
    <link rel="stylesheet" href="/assets/css/color_scheme_v2.dark_mode.css">
    <link rel="stylesheet" href="/assets/css/highlightjs/github-dark.css">
    <title>👯 Unreal 5 多人网络同步源码梳理（基础）</title>
  </head>
  <body>
    <script>hljs.highlightAll();</script>
    <div class="post">
      <div class="sidebar_wrapper_left sidebar_wrapper">
        <div class="navi"><a class="navi_link button" href="/home.html"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" fill="none" version="1.1" width="21" height="20.999996185302734" viewBox="0 0 21 20.999996185302734"><defs><clipPath id="master_svg0_9_0235"><rect x="0" y="0" width="21" height="20.999996185302734" rx="0"/></clipPath></defs><g clip-path="url(#master_svg0_9_0235)"><g><path d="M9.9628,1.059317C10.27877,0.8135611,10.7212,0.8135611,11.03716,1.059317C11.03716,1.059317,18.9122,7.18432,18.9122,7.18432C19.1253,7.35009,19.25,7.60498,19.25,7.875C19.25,7.875,19.25,17.5,19.25,17.5C19.25,18.1962,18.9734,18.8639,18.4811,19.3561C17.9889,19.8484,17.321199999999997,20.125,16.625,20.125C16.625,20.125,4.375,20.125,4.375,20.125C3.67881,20.125,3.01113,19.8484,2.518845,19.3561C2.026561,18.8639,1.75,18.1962,1.75,17.5C1.75,17.5,1.75,7.875,1.75,7.875C1.75,7.60498,1.874664,7.35009,2.087802,7.18432C2.087802,7.18432,9.9628,1.059317,9.9628,1.059317C9.9628,1.059317,9.9628,1.059317,9.9628,1.059317ZM8.75,18.375C8.75,18.375,12.25,18.375,12.25,18.375C12.25,18.375,12.25,11.375,12.25,11.375C12.25,11.375,8.75,11.375,8.75,11.375C8.75,11.375,8.75,18.375,8.75,18.375C8.75,18.375,8.75,18.375,8.75,18.375ZM14,18.375C14,18.375,14,10.5,14,10.5C14,10.01674,13.6083,9.625,13.125,9.625C13.125,9.625,7.875,9.625,7.875,9.625C7.39176,9.625,7,10.01674,7,10.5C7,10.5,7,18.375,7,18.375C7,18.375,4.375,18.375,4.375,18.375C4.14293,18.375,3.92038,18.2828,3.75628,18.1187C3.59219,17.9547,3.5,17.732,3.5,17.5C3.5,17.5,3.5,8.30295,3.5,8.30295C3.5,8.30295,10.5,2.8585000000000003,10.5,2.8585000000000003C10.5,2.8585000000000003,17.5,8.30295,17.5,8.30295C17.5,8.30295,17.5,17.5,17.5,17.5C17.5,17.732,17.4078,17.9547,17.2437,18.1187C17.0796,18.2828,16.857,18.375,16.625,18.375C16.625,18.375,14,18.375,14,18.375C14,18.375,14,18.375,14,18.375Z" fill-rule="evenodd" fill="#373737" fill-opacity="1"/></g></g></svg></a><a class="navi_link button" href="/blogs.html"><svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="#434343"><path d="M520-600v-240h320v240H520ZM120-440v-400h320v400H120Zm400 320v-400h320v400H520Zm-400 0v-240h320v240H120Zm80-400h160v-240H200v240Zm400 320h160v-240H600v240Zm0-480h160v-80H600v80ZM200-200h160v-80H200v80Zm160-320Zm240-160Zm0 240ZM360-280Z"/></svg></a><a class="navi_link button" href="/portfolio.html"><svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="#434343"><path d="M619-108q-11 11-25.5 17T563-85q-16 0-31-6t-26-17l-56-56q-11-11-16.5-24.5T427-216q-1-14 3.5-28t13.5-26l6-8-326-466 156-156 509 509q11 11 17 25.5t6 30.5q0 16-6 31t-17 26L619-108ZM507-335l113-112-340-340-52 52 279 400Zm56 170 169-169-56-57-170 170 57 56Zm-56-170 113-112-113 112Z"/></svg></a><a class="navi_link button" href="/about.html"><svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="#434343"><path d="M194-80v-395h80v315h280v-193l105-105q29-29 45-65t16-77q0-40-16.5-76T659-741l-25-26-127 127H347l-43 43-57-56 67-67h160l160-160 82 82q40 40 62 90.5T800-600q0 57-22 107.5T716-402l-82 82v240H194Zm197-187L183-475q-11-11-17-26t-6-31q0-16 6-30.5t17-25.5l84-85 124 123q28 28 43.5 64.5T450-409q0 40-15 76.5T391-267Z"/></svg></a></div>
      </div>
      <div class="contents">
        <div class="top_gap_space"></div>
        <div class="header"><a class="navi_link button" href="/home.html"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" fill="none" version="1.1" width="21" height="20.999996185302734" viewBox="0 0 21 20.999996185302734"><defs><clipPath id="master_svg0_9_0235"><rect x="0" y="0" width="21" height="20.999996185302734" rx="0"/></clipPath></defs><g clip-path="url(#master_svg0_9_0235)"><g><path d="M9.9628,1.059317C10.27877,0.8135611,10.7212,0.8135611,11.03716,1.059317C11.03716,1.059317,18.9122,7.18432,18.9122,7.18432C19.1253,7.35009,19.25,7.60498,19.25,7.875C19.25,7.875,19.25,17.5,19.25,17.5C19.25,18.1962,18.9734,18.8639,18.4811,19.3561C17.9889,19.8484,17.321199999999997,20.125,16.625,20.125C16.625,20.125,4.375,20.125,4.375,20.125C3.67881,20.125,3.01113,19.8484,2.518845,19.3561C2.026561,18.8639,1.75,18.1962,1.75,17.5C1.75,17.5,1.75,7.875,1.75,7.875C1.75,7.60498,1.874664,7.35009,2.087802,7.18432C2.087802,7.18432,9.9628,1.059317,9.9628,1.059317C9.9628,1.059317,9.9628,1.059317,9.9628,1.059317ZM8.75,18.375C8.75,18.375,12.25,18.375,12.25,18.375C12.25,18.375,12.25,11.375,12.25,11.375C12.25,11.375,8.75,11.375,8.75,11.375C8.75,11.375,8.75,18.375,8.75,18.375C8.75,18.375,8.75,18.375,8.75,18.375ZM14,18.375C14,18.375,14,10.5,14,10.5C14,10.01674,13.6083,9.625,13.125,9.625C13.125,9.625,7.875,9.625,7.875,9.625C7.39176,9.625,7,10.01674,7,10.5C7,10.5,7,18.375,7,18.375C7,18.375,4.375,18.375,4.375,18.375C4.14293,18.375,3.92038,18.2828,3.75628,18.1187C3.59219,17.9547,3.5,17.732,3.5,17.5C3.5,17.5,3.5,8.30295,3.5,8.30295C3.5,8.30295,10.5,2.8585000000000003,10.5,2.8585000000000003C10.5,2.8585000000000003,17.5,8.30295,17.5,8.30295C17.5,8.30295,17.5,17.5,17.5,17.5C17.5,17.732,17.4078,17.9547,17.2437,18.1187C17.0796,18.2828,16.857,18.375,16.625,18.375C16.625,18.375,14,18.375,14,18.375C14,18.375,14,18.375,14,18.375Z" fill-rule="evenodd" fill="#373737" fill-opacity="1"/></g></g></svg></a><a class="navi_link button" href="/blogs.html"><svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="#434343"><path d="M520-600v-240h320v240H520ZM120-440v-400h320v400H120Zm400 320v-400h320v400H520Zm-400 0v-240h320v240H120Zm80-400h160v-240H200v240Zm400 320h160v-240H600v240Zm0-480h160v-80H600v80ZM200-200h160v-80H200v80Zm160-320Zm240-160Zm0 240ZM360-280Z"/></svg></a><a class="navi_link button" href="/portfolio.html"><svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="#434343"><path d="M619-108q-11 11-25.5 17T563-85q-16 0-31-6t-26-17l-56-56q-11-11-16.5-24.5T427-216q-1-14 3.5-28t13.5-26l6-8-326-466 156-156 509 509q11 11 17 25.5t6 30.5q0 16-6 31t-17 26L619-108ZM507-335l113-112-340-340-52 52 279 400Zm56 170 169-169-56-57-170 170 57 56Zm-56-170 113-112-113 112Z"/></svg></a><a class="navi_link button" href="/about.html"><svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="#434343"><path d="M194-80v-395h80v315h280v-193l105-105q29-29 45-65t16-77q0-40-16.5-76T659-741l-25-26-127 127H347l-43 43-57-56 67-67h160l160-160 82 82q40 40 62 90.5T800-600q0 57-22 107.5T716-402l-82 82v240H194Zm197-187L183-475q-11-11-17-26t-6-31q0-16 6-30.5t17-25.5l84-85 124 123q28 28 43.5 64.5T450-409q0 40-15 76.5T391-267Z"/></svg></a></div>
        <div class="page_description">
          <h1 class="title">👯 Unreal 5 多人网络同步源码梳理（基础）</h1>
          <hr>
          <div class="sub_info">
            <p class="date">2025-06-08</p>
            <div class="type_tags">
              <p class="tag">Unreal</p>
              <p class="tag">Cpp</p>
              <p class="type">Dev</p>
            </div>
          </div>
        </div>
        <div class="page_content">
          <blockquote>
            <t class="">笔者撰写本文使用的 UE 版本为 5.5.4</t>
          </blockquote>
          <p>
            <t class="">在 </t>
            <t class="code">NEtDriver.h</t>
            <t class=""> 中，有一段详细的关于 UE 的网络同步机制的介绍。本文首先会在第一章翻译 UE 的注释文档，这对理解网络同步过程与其代码会很有帮助。接着，网络同步主要发生在 Tick 阶段，本文会在第二章中具体看一下 </t>
            <t class="code">UNetDriver</t>
            <t class=""> 类和它的 </t>
            <t class="code">Tick</t>
            <t class=""> 阶段的行为，同时也会涉及一些 </t>
            <t class="code">UIpNetDriver</t>
            <t class=""> 的内容。接下来，UE 对握手流程有一个较为清除的介绍，本文会再深入一些握手的具体代码，看看握手在 UE 源码中的触发时机。</t>
          </p>
          <h1 id="heading1_0" index-text="I">
            <t class="">UE 网络同步系统</t>
          </h1>
          <p>
            <t class="code">NetDriver.h</t>
            <t class=""> 中的注释文档非常详细地介绍了网络同步机制和相关的类与代码。笔者在此先对其进行翻译。理解这部分内容对理解 UE 5 的网络同步机制十分有帮助。</t>
          </p>
          <h2 id="heading2_0">
            <t class="code">NetDriver</t>
            <t class="">, </t>
            <t class="code">NetConnections</t>
            <t class=""> 和 </t>
            <t class="code">Channels</t>
          </h2>
          <p>
            <t class="code">UNetDriver</t>
            <t class=""> 负责管理一系列 </t>
            <t class="code">UNetConnetions</t>
            <t class="">。一些典型的 </t>
            <t class="code">UNetDrivers</t>
            <t class=""> 有：</t>
          </p>
          <ul>
            <li>
              <t class="code">Game NetDriver</t>
              <t class="">：负责正常的游戏网络通信</t>
            </li>
            <li>
              <t class="code">Demo NetDriver</t>
              <t class="">： 负责记录或回放记录的游戏数据，这也是提供回放功能的地方</t>
            </li>
            <li>
              <t class="code">Beacon NetDriver</t>
              <t class="">：负责正常游戏外网络通信</t>
            </li>
          </ul>
          <p>
            <t class="">开发者也可以实现自己的 </t>
            <t class="code">NetDrivers</t>
            <t class="">。</t>
          </p>
          <p>
            <t class="code">NetConnections</t>
            <t class=""> 表示一个连接到游戏（更宽泛的说是 </t>
            <t class="code">NetDriver</t>
            <t class="">）的独立的用户。</t>
          </p>
          <p>
            <t class="">末端数据并不会直接被 </t>
            <t class="code">NetConnections</t>
            <t class=""> 处理，</t>
            <t class="code">NetConnections</t>
            <t class=""> 会将数据发送到 </t>
            <t class="code">Channels</t>
            <t class="">，一般的 </t>
            <t class="code">Channel</t>
            <t class=""> 类型有：</t>
          </p>
          <ul>
            <li>
              <t class="code">Control Channel</t>
              <t class="">：用于发送监控当前连接的数据，比如当前连接是否需要关闭等</t>
            </li>
            <li>
              <t class="code">Voice Channel</t>
              <t class="">：用于在客户端和服务端之间发送声音数据</t>
            </li>
            <li>
              <t class="code">Unique Actor Channel</t>
              <t class=""> 在每个从服务端复制到客户端的 </t>
              <t class="code">Actor</t>
              <t class=""> 都存在</t>
            </li>
          </ul>
          <p>
            <t class="">即使不是很常见，也可能会有使用自定义的 </t>
            <t class="code">Channel</t>
            <t class=""> 的情况。</t>
          </p>
          <h2 id="heading2_1">
            <t class="code">Game Net Drivers</t>
            <t class="">, </t>
            <t class="code">Net Connections</t>
            <t class="">, 和 </t>
            <t class="code">Channels</t>
          </h2>
          <p>
            <t class="">在一般情况下，在服务器和客户端只会存在一个 </t>
            <t class="code">NetDriver</t>
            <t class="">，用于常规的游戏通信和连接。</t>
          </p>
          <p>
            <t class="">服务器的 </t>
            <t class="code">NetDriver</t>
            <t class=""> 会维护一个 </t>
            <t class="code">NetConnection</t>
            <t class=""> 列表，每一个都代表了一个在游戏中的玩家，负责复制 </t>
            <t class="code">Actor</t>
            <t class=""> 数据。</t>
          </p>
          <p>
            <t class="">客户端的 </t>
            <t class="code">NetDriver</t>
            <t class=""> 只有一个 </t>
            <t class="code">NetConnection</t>
            <t class="">，表示与服务器的连接。</t>
          </p>
          <p>
            <t class="">不管是在服务器还是在客户端，</t>
            <t class="code">NetDriver</t>
            <t class=""> 都负责接受来自网络的包，并将它们传递到正确的连接（需要时，建立新的 </t>
            <t class="code">NetConnection</t>
            <t class="">）。</t>
          </p>
          <h2 id="heading2_2">
            <t class="">初始化连接 / 握手流程（Initiating Connections / Handshaking Flow）</t>
          </h2>
          <p>
            <t class="code">UIpNetDriver</t>
            <t class=""> 和 </t>
            <t class="code">UIpConnection</t>
            <t class="">（或者它们的派生类）是引擎在大部分平台的默认选项。下面的文本描述了如何建立和管理连接。这些实现在不同的 </t>
            <t class="code">NetDriver</t>
            <t class=""> 中可能有所不同。</t>
          </p>
          <p>
            <t class="">服务器和客户端拥有它们自己的 </t>
            <t class="code">NetDriver</t>
            <t class="">，所有 UE 游戏复制通信都会在 </t>
            <t class="code">IpNetDriver</t>
            <t class=""> 来发送和接受。这些通信中也包含建立和重新建立连接（如果哪里出错了）的逻辑。</t>
          </p>
          <p>
            <t class="">握手被分在多个地方进行：</t>
            <t class="code">NetDriver</t>
            <t class="">、</t>
            <t class="code">PendingNetGame</t>
            <t class="">、</t>
            <t class="code">World</t>
            <t class="">、</t>
            <t class="code">PacketHandlers</t>
            <t class="">等。将逻辑分在各处是因为需求是分散的。例如：一个连接是否正在发送 </t>
            <t class="code">UE-Protocol</t>
            <t class=""> 数据、一个地址是否有恶意、一个客户端是否有正确的游戏版本等。</t>
          </p>
          <h3 id="heading3_0">
            <t class="">开始设置与握手（Startup and Handshaking）</t>
          </h3>
          <p>
            <t class="">不管一个服务器在什么时候加载地图（通过 </t>
            <t class="code">UEngine::LoadMap</t>
            <t class="">），我们都会调用 </t>
            <t class="code">UWorld::Listen</t>
            <t class="">。它的作用是创建主要的 </t>
            <t class="code">Game Net Driver</t>
            <t class="">，解析设置，并调用 </t>
            <t class="code">UNetDriver::InitListen</t>
            <t class="">。最终，代码负责说明如何具体地监听客户端的连接。例如：在 </t>
            <t class="code">IpNetDriver</t>
            <t class=""> 中，将要被绑定到 IP/Port 会通过 </t>
            <t class="code">Socket Subsystem</t>
            <t class=""> 被决定（见</t>
            <t class="code"> ISocketSubsystem::GetLocalBindAddresses</t>
            <t class=""> 和 </t>
            <t class="code">ISocketSubsystem::BindNextPort</t>
            <t class="">）。</t>
          </p>
          <p>
            <t class="">既然服务器开始监听了，是时候开始接受客户端的连接了。</t>
          </p>
          <p>
            <t class="">不管客户端在什么时候想要加入服务器，它们首先都会在 </t>
            <t class="code">UEngine::Browse</t>
            <t class=""> 中，建立一个有服务器 IP 的新 </t>
            <t class="code">UPendingNetGame</t>
            <t class="">。
</t>
            <t class="code">UPendingNetGame::Initialize</t>
            <t class=""> 和 </t>
            <t class="code">UPendingNetGame::InitNetDriver</t>
            <t class=""> 负责进行初始化，并会各自设置 </t>
            <t class="code">NetDriver</t>
            <t class="">。
在这个初始化过程中，客户端将会立即为服务器设置 </t>
            <t class="code">UNetConnection</t>
            <t class="">，并开始通过这个连接发送数据，来初始化握手过程。</t>
          </p>
          <p>
            <t class="">不管是在客户端还是在服务端，</t>
            <t class="code">UNetDriver::TickDispatch</t>
            <t class=""> 都负责接受网络数据。通常来说，当我们接受到一个包时，我们会检查它的地址，看看我们知不知道这个地址。我们需要确定我们有没有对这个源地址建立了连接，这件事通过简单地维护一个键为 </t>
            <t class="code">FInternetAddr</t>
            <t class="">，值为 </t>
            <t class="code">UNetConnection</t>
            <t class=""> 的表完成。</t>
          </p>
          <p>
            <t class="">如果一个包来自一个已经建立的连接，我们将包通过 </t>
            <t class="code">UNetConnection::ReceivedRawPacket</t>
            <t class=""> 传入连接。如果一个包来自一个没有被建立的连接，我们认为它是 </t>
            <t class="code">connectionless</t>
            <t class="">（下文称“无连接的”），并尝试开始握手。要了解如何握手，见 </t>
            <t class="code">StatelessConnectionHandlerComponent.cpp</t>
            <t class="">。</t>
          </p>
          <h3 id="heading3_1">
            <t class="code">UWorld / UPendingNetGame / AGameModeBase Startup and Handshaking</t>
          </h3>
          <p>
            <t class="">在 </t>
            <t class="code">UNetDriver</t>
            <t class=""> 和 </t>
            <t class="code">UNetConnection</t>
            <t class=""> 在服务器和客户端完成了它们的握手工作后。
客户端将会触发 </t>
            <t class="code">UPendingNetGame::SendInitialJoin</t>
            <t class=""> 游戏级别（game level）的握手。</t>
          </p>
          <p>
            <t class="">游戏基本的握手大部分在 </t>
            <t class="code">FNetControlMessages</t>
            <t class=""> 完成。完整的控制信息集合可以见 </t>
            <t class="code">DataChannel.h</t>
            <t class="">。</t>
          </p>
          <p>
            <t class="">大部分处理这些控制信息的工作是同时在 </t>
            <t class="code">UWorld::NotifyControlMessage</t>
            <t class=""> 和 </t>
            <t class="code">UPendingNetGame::NotifyControlMessage</t>
            <t class=""> 完成的。大致流程如下：</t>
          </p>
          <blockquote>
            <t class="">使用挑战-响应（challenge-response）机制</t>
          </blockquote>
          <ul>
            <li>
              <t class="">客户端的 </t>
              <t class="code">UPendingNetGame::SendInitialJoin</t>
              <t class=""> 发送 </t>
              <t class="code">NMT_Hello</t>
            </li>
            <li>
              <t class="">服务器的 </t>
              <t class="code">UWorld::NotifyControlMessage</t>
              <t class=""> 接收 </t>
              <t class="code">NMT_Hello</t>
              <t class="">，并发送 </t>
              <t class="code">NMT_Challenge</t>
            </li>
            <li>
              <t class="">客户端的 </t>
              <t class="code">UPendingNetGame::NotifyControlMessage</t>
              <t class=""> 接收 </t>
              <t class="code">NMT_Challenge</t>
              <t class=""> 并在 </t>
              <t class="code">NMT_Login</t>
              <t class=""> 中发回数据</t>
            </li>
            <li>
              <t class="">服务器的 </t>
              <t class="code">UWorld::NotifyControlMessage</t>
              <t class=""> 接收 </t>
              <t class="code">NMT_Login</t>
              <t class="">，验证质询数据（challenge data），并调用 </t>
              <t class="code">AGameModeBase::PreLogin</t>
            </li>
            <li>
              <t class="">如果 </t>
              <t class="code">PreLogin</t>
              <t class=""> 并没有报任何错误，服务器会调用 </t>
              <t class="code">UWorld::WelcomePlayer</t>
              <t class="">，这个函数会调用 </t>
              <t class="code">AGameModeBase::GameWelcomePlayer</t>
              <t class=""> 并发送含有地图信息的 </t>
              <t class="code">NMT_Welcome</t>
            </li>
            <li>
              <t class="">客户端的 </t>
              <t class="code">UPendingNetGame::NotifyControlMessage</t>
              <t class=""> 接收 </t>
              <t class="code">NMT_Welcome</t>
              <t class="">，并读取地图信息（以便于后续加载），然后发送 </t>
              <t class="code">NMT_NetSpeed</t>
              <t class=""> 信息，这里包含了客户端配置了的网络速度（Net Speed）</t>
            </li>
            <li>
              <t class="">服务器的 </t>
              <t class="code">UWorld::NotifyControlMessage</t>
              <t class=""> 接收 </t>
              <t class="code">NMT_NetSpeed</t>
              <t class="">，然后调整到正确的网络速度</t>
            </li>
          </ul>
          <p>
            <t class="">在此时，握手基本上可以认为完成了。玩家已经完全连接了游戏。此外，根据加载地图的时间，客户端可能还会在控制权转移到 </t>
            <t class="code">UWorld</t>
            <t class=""> 之前，在 </t>
            <t class="code">UPendingNetGame</t>
            <t class=""> 接收到一些非握手的控制信息（control messages）。必要时，还可以采取一些其它步骤来处理加密（Encryption）。</t>
          </p>
          <h3 id="heading3_2">
            <t class="">重新建立丢失的连接（Reestablishing Lost Connections）</t>
          </h3>
          <p>
            <t class="">在整个游戏过程中，有很多原因可以导致用户的连接丢失——互联网中断、从 LET 切换到 WIFI、离开游戏等。</t>
          </p>
          <ul>
            <li>
              <t class="">initiated：发起</t>
            </li>
          </ul>
          <p>
            <t class="">如果服务器服务器发起了断开连接，或者意识到了其中一个情况（由于超时或错误），断开连接将会关闭 </t>
            <t class="code">UNetConnection</t>
            <t class=""> 并告知（Notify）游戏的方式以被处理。这是，由游戏决定是否支持 Join In Progress 或 Rejoins 机制。如果游戏不支持，那么我们会重新走一遍上面讲述过的握手流程。</t>
          </p>
          <ul>
            <li>
              <t class="">albeit：尽管</t>
            </li>
          </ul>
          <p>
            <t class="">如果客户端的连接只是服务器意识不到的短暂中断（interrupts），引擎/游戏通常会自动修复，尽管会存在一些丢包（packet loss）和延迟峰值（lag spike）。</t>
          </p>
          <p>
            <t class="">然而，如果客户端的 IP 地址或端口改变但服务器意识不到这点，将会开始一段修复流程。修复流程会重新进行底层握手，此时游戏代码并不会警告。与此相关的代码在 </t>
            <t class="code">StatlessConnectionHandlerComponent.cpp</t>
            <t class=""> 中。</t>
          </p>
          <h2 id="heading2_3">
            <t class="">数据传输（Data Transmission）</t>
          </h2>
          <p>
            <t class="">游戏的 </t>
            <t class="code">NetConnecitons</t>
            <t class=""> 和 </t>
            <t class="code">NetDrivers</t>
            <t class=""> 通常与底层所使用的通信方法/技术无关。这些留给了它们的派生类去处理（如 </t>
            <t class="code">UOpConnectio</t>
            <t class=""> / </t>
            <t class="code">UIpNetDriver</t>
            <t class=""> 或者 </t>
            <t class="code">UWebSocketConnection</t>
            <t class=""> / </t>
            <t class="code">UWebSocketNetDriver</t>
            <t class="">）。</t>
          </p>
          <p>
            <t class="">相反的，</t>
            <t class="code">UNetDriver</t>
            <t class=""> 和 </t>
            <t class="code">UNetConnection</t>
            <t class=""> 与 </t>
            <t class="code">Packets</t>
            <t class=""> 和 </t>
            <t class="code">Bunches</t>
            <t class=""> 一起工作。</t>
          </p>
          <p>
            <t class="code">Packet</t>
            <t class="">（包）是一堆主机与用户的 </t>
            <t class="code">NetConnection</t>
            <t class=""> 间，互相发送的数据块（blob）。它包含包本身的元数据，例如头文件信息和知识产权，还有 </t>
            <t class="code">Bunches</t>
            <t class="">。</t>
          </p>
          <p>
            <t class="code">Bunch</t>
            <t class="">（束）是一对用户和主机的 </t>
            <t class="code">Channel</t>
            <t class=""> 间，互相发送的数据块（blob）。当一个连接接收了一个包，这个包将被拆成单独的束。这些束接着被传入独立的 </t>
            <t class="code">Channel</t>
            <t class="">，等待之后被处理。</t>
          </p>
          <p>
            <t class="">一个包可能不包含束、包含一个或多个束。因为 UE 中，多个束的大小限制可能比一个单独的包要大，所以 UE 支持“子束标记”（notion of partial bunches）：</t>
          </p>
          <p>
            <t class="">当一个束太大时，它会被分成多个小束，这些束会被打上 </t>
            <t class="code">PartialInitial</t>
            <t class="">、</t>
            <t class="code">Partial</t>
            <t class=""> 或 </t>
            <t class="code">PartialFinal</t>
            <t class=""> 的标记，使用这些信息，我们可以再接收后重新组合这些束回一个整体。</t>
          </p>
          <p>
            <t class="">例子 - 客户端 RPC 服务器：</t>
          </p>
          <ul>
            <li>
              <t class="">客户端调用 </t>
              <t class="code">Server_RPC</t>
            </li>
            <li>
              <t class="">这个请求将会通过 </t>
              <t class="code">NetDriver</t>
              <t class=""> 和 </t>
              <t class="code">NetConnection</t>
              <t class=""> 被转发（forwarded）到对应 Actor 的 Actor Channel</t>
            </li>
            <li>
              <t class="">这个 Actor Channel 会序列化 RPC 标识符和参数到一个带有这个 Actor Channel 的 ID 的束中</t>
            </li>
            <li>
              <t class="">Actor Channel 向 </t>
              <t class="code">NetConnection</t>
              <t class=""> 请求发送束</t>
            </li>
            <li>
              <t class="">接着，</t>
              <t class="code">NetConnection</t>
              <t class=""> 将会组合这些数据到一个包中，被发送到服务器</t>
            </li>
            <li>
              <t class="">在服务器中，包会被 </t>
              <t class="code">NetDriver</t>
              <t class=""> 接收</t>
            </li>
            <li>
              <t class="code">NetDriver</t>
              <t class=""> 讲话检查包的源地址，并将包交给适当的 </t>
              <t class="code">NetConnection</t>
            </li>
            <li>
              <t class="">对应的 </t>
              <t class="code">NetConnection</t>
              <t class=""> 会把包拆称束</t>
            </li>
            <li>
              <t class="code">NetConnection</t>
              <t class=""> 会使用束包含的 Actor Channel ID 来把束发送到对应的 Actor Channel、</t>
            </li>
            <li>
              <t class="">Actor Channel 会拆开束，查看其包含的 RPC 数据，然后使用 RPC ID 和被序列化的参数去调用 Actor 的函数</t>
            </li>
          </ul>
          <h3 id="heading3_3">
            <t class="">可靠性和重新传输（Reliability and Retransmission）</t>
          </h3>
          <p>
            <t class="">UE 网络通常假设底层网络协议无法保证可靠性。所以它为包（Packet）和束（Bunch）实现了自己的可靠性和重新传输。</t>
          </p>
          <p>
            <t class="">当一个 </t>
            <t class="code">NetConnection</t>
            <t class=""> 被建立，它会为它的包和束们建立一个序列号（Sequence Number），即包号（pack number）和束号（bunch number）。序列号既可能是固定的，也可能是随机的（随机的序列号由服务器发送）。</t>
          </p>
          <p>
            <t class="">对于每个 </t>
            <t class="code">NetConnection</t>
            <t class="">，每个包会包含一个包号，在每次发送包时都会增加。包号永远不会重复。</t>
          </p>
          <p>
            <t class="">对于每个 </t>
            <t class="code">Channel</t>
            <t class="">，每个可靠（reliable）束都会有一个束号，在每个可靠束发送时，束号会增长。与包不同，可靠束可能会被重新传输，所以我们可能会发送相同束号的束。</t>
          </p>
          <p>
            <t class="">注意，包号和束号都只是序列号，它们没有本质区别。这里区分仅为了更清晰的理解。</t>
          </p>
          <h3 id="heading3_4">
            <t class="">接收侧检测丢包（Detecting Incoming Dropped Packets）</t>
          </h3>
          <p>
            <t class="">因为指定了包号，我们可以很轻松的检测什么时候发生了丢包。只要比对上一次成功接收的包和这一次成功接收的包的包号是否是连续的，就能判断是否丢包了。两次包号的差值 - 1 就是丢包的数量。</t>
          </p>
          <p>
            <t class="">如果发现两次包号间的差值是 0 或负数，因为引擎不会重用序列号，说明我们只可能接收了更早发出的包还没接收到的包，或者外部服务正在尝试重新给我们发送数据。不管是哪种情况，引擎通常都会忽略这些丢失和不合法的包，也不会为它们发送 ACK（确认应答）。</t>
          </p>
          <p>
            <t class="">如果在同一帧收到了顺序不对的包，我们有办法将它们修复（如果这项功能被启用）：如果我们收到了一个与上一次包的差值大于 1 的包，说明中间有包没有到达。我们把当前接收到的包缓存到一个队列中，当下一次我们接收到一个正确顺序的包，再检查和之前接收到的包的顺序关系是否正确，如果正确，我们执行它们；如果还不正确，我们继续接收包。</t>
          </p>
          <p>
            <t class="">当我们读取完所有的目前有效的包后，我们会清理这个队列，执行里面的所有残留包。同时，所有丢失的都会被认为被丢弃。</t>
          </p>
          <p>
            <t class="">接收侧每成功接收一个包都会发送它的包号作为 ACK（确认应答）。</t>
          </p>
          <h3 id="heading3_5">
            <t class="">发出侧检测丢包（Detecting Outgoing Dropped Packets）</t>
          </h3>
          <p>
            <t class="">上面提到了，接收侧每成功接收一个包都会发送它的包号作为 ACK。这些 ACK 会包含顺序的包号。
与接收者追踪包号类似，发送者也会追踪最大的 ACK 的包号。当 ACKs 被处理时，任何小于我们最后接收到的 ACK 的包号会被忽略，同时，任何包号间的间隙都被认为是 Not Acknowledged （NAKed，未应答的）。</t>
          </p>
          <p>
            <t class="">发送者负责处理这些 ACKs 和 NAKs，同时用新的包号重新发送丢失的数据，新的数据将会被添加到新的发送包中。</t>
          </p>
          <h3 id="heading3_6">
            <t class="">重新发送丢失数据（Resending Missing Data）</t>
          </h3>
          <p>
            <t class="">上文提到了，包本身不包含有用的数据，而是束承载着它们。束可以被标记为可靠（Reliable）或者不可靠的（Unreliable）。</t>
          </p>
          <p>
            <t class="">对于不可靠的束，引擎不会尝试重新发送丢失的数据。因此，如果一个束被标记为不可靠的，引擎没有它必须可以继续运行，或者使用外部的重试机制，亦或是冗余地发送该数据。</t>
          </p>
          <p>
            <t class="">下面的所有内容会用来介绍可靠束。</t>
          </p>
          <p>
            <t class="">无论何时，一个可靠束被发送，它将被加入到一个非 ACKed 可靠束列表。如果我们接收了一个包含了可靠束的 NAK 的包，引擎将会重新传输一个一样的束的拷贝。注意，因为束可能可以被分成子束，丢掉一个子束也会导致让整个束重新传输。</t>
          </p>
          <p>
            <t class="">当所有包含束这个可靠束的包 ACK 了，我们才把这个可靠束从上述的列表移除。</t>
          </p>
          <p>
            <t class="">与包相似，我们比对最后成功接收的束的序列号，如果发现差值为负数，我们认为我们丢失了一个束。与包的是处理不同的是，我们不会丢掉这个数据。相反地，我们会将这个束加入到队列，并暂停处理任何束，不管是可靠还是不可靠的。</t>
          </p>
          <p>
            <t class="">直到我们接收到丢失的束之前，处理都不会再继续进行。接收到丢失的束之后，我们后处理这个束和刚刚队列里的束们。</t>
          </p>
          <p>
            <t class="">任何新的，在等待丢失束期间被接收到的束，不会被立刻处理，而是会被加入队列。</t>
          </p>
          <h1 id="heading1_1" index-text="II">
            <t class="">重要概念</t>
          </h1>
          <p>
            <t class="">除了第一章中的重要概念外，本章会介绍一些上文未出现的重要概念，这些概念在源码中经常见到。</t>
          </p>
          <p>
            <t class="bold">网络指标（Network Metric）</t>
            <t class=""> 如其名称，是供开发者评估和调试网络性能的指标。在 UE 网络同步部分的源码中，会有许多更新网络指标的代码，其往往与 </t>
            <t class="code">Metric</t>
            <t class=""> 字眼相关。开发者也可以自行注册网络指标，以及监听网络指标更新事件。具体可见 </t>
            <t class="code">GetMetrics()</t>
            <t class=""> 与 </t>
            <t class="code">NetworkMetricsDatabase.h</t>
            <t class="">。</t>
          </p>
          <h1 id="heading1_2" index-text="III">
            <t class="">源代码梳理 - Tick 阶段</t>
          </h1>
          <p>
            <t class="code">UNetDriver</t>
            <t class=""> 是 UE 网络处理的核心，在 </t>
            <t class="code">UNetDriver</t>
            <t class=""> 中有一些重要的字段：</t>
          </p>
          <ul>
            <li>
              <t class="code">ServerConnection</t>
              <t class=""> 与服务端的连接，为 </t>
              <t class="code">nullptr</t>
              <t class=""> 说明当前运行在服务器上</t>
            </li>
            <li>
              <t class="code">ClientConnections</t>
              <t class=""> 与客户端的连接列表</t>
            </li>
            <li>
              <t class="code">MappedClientConnections</t>
              <t class=""> IP 到连接的表</t>
            </li>
          </ul>
          <p>
            <t class="code">UNetDriver</t>
            <t class=""> 的工作主要发生在世界的 Tick 中，且分在不同的阶段完成。下面的是世界的 Tick 函数与事件的触发顺序，</t>
            <t class="code">On</t>
            <t class=""> 开头的代表事件。</t>
          </p>
          <ol>
            <li>
              <t class="code">World::Tick</t>
            </li>
            <li>
              <t class="code">OnTickDispatch</t>
            </li>
            <li>
              <t class="code">PrePhysics</t>
            </li>
            <li>
              <t class="code">ActorTick</t>
            </li>
            <li>
              <t class="code">OnPostTickDispatch</t>
            </li>
            <li>
              <t class="code">OnPreTickFlush</t>
            </li>
            <li>
              <t class="code">OnTickFlush</t>
            </li>
            <li>
              <t class="code">OnPostTickFlush</t>
            </li>
          </ol>
          <p>
            <t class="">网络相关的内容主要发生在这四个事件中：</t>
          </p>
          <ol>
            <li>
              <t class="code">OnTickDispatch</t>
            </li>
            <li>
              <t class="code">OnPostTickDispatch</t>
            </li>
            <li>
              <t class="code">OnTickFlush</t>
            </li>
            <li>
              <t class="code">OnPostTickFlush</t>
            </li>
          </ol>
          <p>
            <t class="">下面是 </t>
            <t class="code">UNetDriver</t>
            <t class=""> 注册这四个事件的代码：</t>
          </p>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang">c++</div>
              <pre><code class="language-c++">// NetDriver.cpp
void UNetDriver::RegisterTickEvents(class UWorld* InWorld)
{
  if (InWorld)
  {
    TickDispatchDelegateHandle = InWorld-&gt;OnTickDispatch().AddUObject(this, &amp;UNetDriver::InternalTickDispatch);
    PostTickDispatchDelegateHandle  = InWorld-&gt;OnPostTickDispatch().AddUObject(this, &amp;UNetDriver::PostTickDispatch);
    TickFlushDelegateHandle = InWorld-&gt;OnTickFlush().AddUObject(this, &amp;UNetDriver::InternalTickFlush);
    PostTickFlushDelegateHandle = InWorld-&gt;OnPostTickFlush().AddUObject(this, &amp;UNetDriver::PostTickFlush);
  }
}
</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <div class="table">
            <table>
              <tr>
                <td>调用阶段</td>
                <td>主要函数（UNetDriver）</td>
                <td>备注</td>
              </tr>
              <tr>
                <td>OnTickDispatch</td>
                <td>TickDispatch</td>
                <td>通过 InternalTickDispatch 调用，Internal 中间层目的是防止非法递归调用</td>
              </tr>
              <tr>
                <td>OnPostTickDispatch</td>
                <td>PostTickDispatch</td>
                <td></td>
              </tr>
              <tr>
                <td>OnTickFlush</td>
                <td>TickFlush</td>
                <td>通过 InternalTickFlush 调用，Internal 作用如上&lt;br&gt;</td>
              </tr>
              <tr>
                <td>OnPostTickFlush</td>
                <td>PostTickFlush</td>
                <td></td>
              </tr>
              <tr>
                <td>下文会按顺序详细介绍上述四个函数。</td>
                <td></td>
                <td></td>
              </tr>
            </table>
          </div>
          <h2 id="heading2_4">
            <t class="code">TickDispatch</t>
          </h2>
          <p>
            <t class="">这个函数主要完成接收数据的工作。</t>
          </p>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang">c++</div>
              <pre><code class="language-c++">// NetDriver.cpp/UNetDriver::TickDispatch

void UNetDriver::TickDispatch( float DeltaTime )
{
  SendCycles=0;

  // Manage realtime values
  {
    const double CurrentRealtime = FPlatformTime::Seconds();
    LastTickDispatchRealtime = CurrentRealtime;

    // Check to see if too much time is passing between ticks
    // Setting this to somewhat large value for now, but small enough to catch blocking calls that are causing timeouts
    constexpr float TickLogThreshold = 5.0f;

    const float DeltaRealtime = CurrentRealtime - LastTickDispatchRealtime;
    bDidHitchLastFrame = (DeltaTime &gt; TickLogThreshold || DeltaRealtime &gt; TickLogThreshold);

    if (bDidHitchLastFrame)
    {
      UE_LOG( LogNet, Log, TEXT( &quot;UNetDriver::TickDispatch: Very long time between ticks. DeltaTime: %2.2f, Realtime: %2.2f. %s&quot; ), DeltaTime, DeltaRealtime, *GetName() );
    }
  }

  // Get new time.
  ElapsedTime += DeltaTime;

  IncomingBunchProcessingElapsedFrameTimeMS = 0.0f;</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <p>
            <t class="">上面这段代码主要更新现实时间相关的内容，并在帧时间过长时打印日志。</t>
          </p>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang">c++</div>
              <pre><code class="language-c++">  // Checks for standby cheats if enabled
  UpdateStandbyCheatStatus();
  ResetNetworkMetrics();</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <ul>
            <li>
              <t class="code">ResetNetworkMetrics</t>
              <t class=""> 负责重置网络指标</t>
            </li>
          </ul>
          <p>
            <t class="">接下来是服务器侧的逻辑，在服务器逻辑中，</t>
          </p>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang">c++</div>
              <pre><code class="language-c++">  if (ServerConnection == nullptr)
  {
    // Delete any straggler connections
    {
      QUICK_SCOPE_CYCLE_COUNTER(UNetDriver_TickDispatch_CheckClientConnectionCleanup)

      for (int32 ConnIdx=ClientConnections.Num()-1; ConnIdx&gt;=0; ConnIdx--)
      {
        UNetConnection* CurConn = ClientConnections[ConnIdx];

        if (IsValid(CurConn))
        {
          if (CurConn-&gt;GetConnectionState() == USOCK_Closed)
          {
            CurConn-&gt;CleanUp();
          }
          else
          {
            CurConn-&gt;PreTickDispatch();
          }
        }
      }
    }</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <p>
            <t class="">首先会逆序遍历 </t>
            <t class="code">ClientConnections</t>
            <t class="">，检查连接的合法性，如果不合法，连接被安全清除；如果合法，则调用对应连接的 </t>
            <t class="code">PreTickDispatch()</t>
            <t class="">。被 CleanUp 的连接并不会立刻被销毁，而是会被存储在 </t>
            <t class="code">RecentlyDisconnectedClients</t>
            <t class=""> 中，被追踪一段时间，当超过预设的追踪时间后，才会最终从 </t>
            <t class="code">RecentlyDisconnectedClients</t>
            <t class=""> 删除，意味着被销毁。上述逻辑的代码如下：</t>
          </p>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang">c++</div>
              <pre><code class="language-c++">    // Clean up recently disconnected client tracking
    if (RecentlyDisconnectedClients.Num() &gt; 0)
    {
      int32 NumToRemove = 0;

      for (const FDisconnectedClient&amp; CurElement : RecentlyDisconnectedClients)
      {
        if ((LastTickDispatchRealtime - CurElement.DisconnectTime) &gt;= RecentlyDisconnectedTrackingTime)
        {
          verify(MappedClientConnections.Remove(CurElement.Address) == 1);

          NumToRemove++;
        }
        else
        {
          break;
        }
      }

      if (NumToRemove &gt; 0)
      {
        RecentlyDisconnectedClients.RemoveAt(0, NumToRemove);
      }
    }
  }</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <p>
            <t class="">说完了服务器侧，下面的代码与客户端侧有关</t>
          </p>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang">c++</div>
              <pre><code class="language-c++">  else if (IsValid(ServerConnection))
  {
    ServerConnection-&gt;PreTickDispatch();
  }

#if RPC_CSV_TRACKER
  GReceiveRPCTimingEnabled = (NetDriverName == NAME_GameNetDriver &amp;&amp; ShouldEnableScopeSecondsTimers()) &amp;&amp; (ServerConnection==nullptr);
#endif
}</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <p>
            <t class="">客户端的行为则是执行 </t>
            <t class="code">PreTickDispatch</t>
            <t class="">，这个函数的具体作用是 DoS 防护与错误恢复的 Tick 行为，这里不详细介绍。</t>
          </p>
          <p>
            <t class="">在 </t>
            <t class="code">UNetDriver</t>
            <t class=""> 的派生类 </t>
            <t class="code">UIpNetDriver</t>
            <t class=""> 中，才包含接收包的逻辑：</t>
          </p>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang">c++</div>
              <pre><code class="language-c++">void UIpNetDriver::TickDispatch(float DeltaTime)
{
  LLM_SCOPE_BYTAG(NetDriver);

  Super::TickDispatch( DeltaTime );

  const bool bUsingReceiveThread = SocketReceiveThreadRunnable.IsValid();

  if (bUsingReceiveThread)
  {
    SocketReceiveThreadRunnable-&gt;PumpOwnerEventQueue();
  }</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <p>
            <t class="">若启用了接收线程，则处理接收线程的数据。</t>
          </p>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang">c++</div>
              <pre><code class="language-c++">#if !UE_BUILD_SHIPPING
  ...
#endif
  ...
  // Process all incoming packets
  for (FPacketIterator It(this); It; ++It)
  {</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <p>
            <t class="">迭代器遍历所有到达的包，下面开始处理这些包。</t>
          </p>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang">c++</div>
              <pre><code class="language-c++">    FReceivedPacketView ReceivedPacket;
    FInPacketTraits&amp; ReceivedTraits = ReceivedPacket.Traits;
    bool bOk = It.GetCurrentPacket(ReceivedPacket);
    const TSharedRef&lt;const FInternetAddr&gt; FromAddr = ReceivedPacket.Address.ToSharedRef();
    UNetConnection* Connection = nullptr;
    UIpConnection* const MyServerConnection = GetServerConnection();

    if (bOk)
    {
      // Immediately stop processing (continuing to next receive), for empty packets (usually a DDoS)
      if (ReceivedPacket.DataView.NumBits() == 0)
      {
        DDoS.IncBadPacketCounter();
        continue;
      }

      FPacketAudit::NotifyLowLevelReceive((uint8*)ReceivedPacket.DataView.GetData(), ReceivedPacket.DataView.NumBytes());
    }</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <ul>
            <li>
              <t class="code">bOk</t>
              <t class=""> 代表当前数据包是否可被处理</t>
            </li>
          </ul>
          <p>
            <t class="">如果接收到数据包大小为 0 的疑似错误包或攻击包的无效包，统计并直接跳过；如果不是，则调用 </t>
            <t class="code">NotifyLowLevelReceive</t>
            <t class=""> 处理来包。</t>
          </p>
          <p>
            <t class="">接着是不 </t>
            <t class="code">bOk</t>
            <t class=""> 的情况，会进行错误处理：</t>
          </p>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang">c++</div>
              <pre><code class="language-c++">    else
    {
      if (IsRecvFailBlocking(ReceivedPacket.Error))
      {
        break;
      }
      else if (ReceivedPacket.Error != SE_ECONNRESET &amp;&amp; ReceivedPacket.Error != SE_UDP_ERR_PORT_UNREACH)
      {
        //...log
        continue;
      }
    }</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <p>
            <t class="">如果遇到阻塞性的错误，则直接跳出循环。如果包体过大，可能为恶意攻击，客户端可能被重置等问题。</t>
          </p>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang">c++</div>
              <pre><code class="language-c++">    if (MyServerConnection)
    {
      if (MyServerConnection-&gt;RemoteAddr-&gt;CompareEndpoints(*FromAddr))
      {
        Connection = MyServerConnection;
      }
      else //...log
    }

    if (Connection == nullptr) { ... }
    if( bOk == false ) { if( Connection ) { ... } }
    else {
      bool bIgnorePacket = false;
      // If we didn't find a client connection, maybe create a new one.
      if (Connection == nullptr) { ... }
    }
  }

  if (NewIPHashes.Num() &gt; 0) TickNewIPTracking(DeltaTime);
  DDoS.PostFrameReceive();
}</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <p>
            <t class="">后半部分则主要与处理连接有关。包括处理新的连接请求，将接收到的数据分发到连接等。</t>
          </p>
          <h2 id="heading2_5">
            <t class="code">PostTickDispatch</t>
          </h2>
          <p>
            <t class="code">PostTickDispatch()</t>
            <t class=""> 负责结束任务分发。</t>
          </p>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang">c++</div>
              <pre><code class="language-c++">void UNetDriver::PostTickDispatch()
{
  // Flush out of order packet caches for connections that did not receive the missing packets during TickDispatch
  if (ServerConnection != nullptr)
  {
    if (IsValid(ServerConnection))
    {
      ServerConnection-&gt;PostTickDispatch();
    }
  }

  TArray&lt;UNetConnection*&gt; ClientConnCopy = ClientConnections;
  for (UNetConnection* CurConn : ClientConnCopy)
  {
    if (IsValid(CurConn))
    {
      CurConn-&gt;PostTickDispatch();
    }
  }</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <p>
            <t class="">函数首先会执行每个连接的 </t>
            <t class="code">PostTickDispatch</t>
            <t class="">。如上面的代码所示：若为客户端，调用客户端连接的函数；若为服务器，安全地遍历客户端连接列表并调用函数。在 </t>
            <t class="code">UNetConnection::PostTickDispatch</t>
            <t class=""> 中，连接会刷新缓存包队列，这个队列用于等待丢失的包到来之前缓存到达的包。同时也会调用 </t>
            <t class="code">RPCDoS</t>
            <t class=""> 的 </t>
            <t class="code">PostTickDispatch()</t>
            <t class="">。</t>
          </p>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang">c++</div>
              <pre><code class="language-c++">#if UE_WITH_IRIS
  PostDispatchSendUpdate();
#endif

  if (ReplicationDriver)
  {
    ReplicationDriver-&gt;PostTickDispatch();
  }</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <ul>
            <li>
              <t class="code">ReplicationDriver-&gt;PostTickDispatch()</t>
              <t class=""> 是一个空实现，暂时没有任何行为</t>
            </li>
          </ul>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang">c++</div>
              <pre><code class="language-c++">  if (GReceiveRPCTimingEnabled)
  {
    GRPCCSVTracker.EndTickDispatch();
    GReceiveRPCTimingEnabled = false;
  }

  if (bPendingDestruction)
  {
    if (World)
    {
      GEngine-&gt;DestroyNamedNetDriver(World, NetDriverName);
    }
    else
    {
      UE_LOG(LogNet, Error, TEXT(&quot;NetDriver %s pending destruction without valid world.&quot;), *NetDriverName.ToString());
    }
    bPendingDestruction = false;
  }
}</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <h2 id="heading2_6">
            <t class="code">TickFlush</t>
          </h2>
          <p>
            <t class="code">NetDriver</t>
            <t class=""> 的主要工作发生在 </t>
            <t class="code">TickFlush</t>
            <t class=""> 中。</t>
          </p>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang">c++</div>
              <pre><code class="language-c++">void UNetDriver::TickFlush(float DeltaSeconds)
{
  // ...trace

  bool bEnableTimer = (NetDriverName == NAME_GameNetDriver) &amp;&amp; ShouldEnableScopeSecondsTimers();
  if (bEnableTimer)
  {
    GTickFlushGameDriverTimeSeconds = 0.0;
  }
  FSimpleScopeSecondsCounter ScopedTimer(GTickFlushGameDriverTimeSeconds, bEnableTimer);</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <p>
            <t class="">如上面的代码所示，引擎首先会初始化计时器。接着开始执行 Actor 复制：</t>
          </p>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang">c++</div>
              <pre><code class="language-c++">  if (IsServer() &amp;&amp; ClientConnections.Num() &gt; 0 &amp;&amp; !bSkipServerReplicateActors)
  {
    // Update all clients.
#if WITH_SERVER_CODE
    CSV_SCOPED_TIMING_STAT_EXCLUSIVE(ServerReplicateActors);

#if UE_WITH_IRIS
    ...
#endif // UE_WITH_IRIS
    {
      ServerReplicateActors(DeltaSeconds);
    }
#endif // WITH_SERVER_CODE
  }
#if UE_WITH_IRIS
  ...
#endif // UE_WITH_IRIS</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <p>
            <t class="">上述代码对应着服务器的复制（Replication） 机制，由于在 UE 5 中新出了 Iris 复制机制，于此出现了许多宏来区分传统的复制与 Iris 复制。Iris 机制会在后面一章中具体解释，这里为了便于阅读暂时省略。传统的复制机制发生在 </t>
            <t class="code">ServerReplicateActors()</t>
            <t class=""> 函数中。</t>
          </p>
          <hr class="divider_block">
          <h3 id="heading3_7">
            <t class="code">ServerReplicateActors()</t>
          </h3>
          <p>
            <t class="">复制所有与连接相关的 Actors。首先会构建一个相关的 Actor 列表，接着，尝试去复制每一个 Actor 到与他们相关的连接。直到一个连接饱和。</t>
          </p>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang">c++</div>
              <pre><code class="language-c++">int32 UNetDriver::ServerReplicateActors(float DeltaSeconds)
{
  SCOPE_CYCLE_COUNTER(STAT_NetServerRepActorsTime);

#if WITH_SERVER_CODE
  if ( ClientConnections.Num() == 0 ) { return 0; }</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <p>
            <t class="code">WITH_SERVER_CODE</t>
            <t class=""> 直接连着函数的结尾，意味着这个函数只在服务器上运行，如果在客户端执行，会直接返回 0。上面的代码还判断了，在没有服务端连接时，引擎直接跳过同步。</t>
          </p>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang">c++</div>
              <pre><code class="language-c++">  GetMetrics()-&gt;SetInt(UE::Net::Metric::NumReplicatedActors,0 );
  GetMetrics()-&gt;SetInt(UE::Net::Metric::NumReplicatedActorBytes, 0);</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <p>
            <t class="">初始化统计指标。</t>
          </p>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang">c++</div>
              <pre><code class="language-c++">#if CSV_PROFILER_STATS
  FScopedNetDriverStats NetDriverStats(this);
  GNumClientConnections = ClientConnections.Num();
#endif

  if (ReplicationDriver)
  {
    return ReplicationDriver-&gt;ServerReplicateActors(DeltaSeconds);
  }</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <p>
            <t class="">引擎会再检查引擎是否支持 Iris 的 </t>
            <t class="code">ReplicationDriver</t>
            <t class="">，如果支持，则使用 Iris。如果不能，执行接下来的传统复制逻辑的代码。</t>
          </p>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang">c++</div>
              <pre><code class="language-c++">  check( World );

  // Bump the ReplicationFrame value to invalidate any properties marked as &quot;unchanged&quot; for this frame.
  ReplicationFrame++;

  int32 Updated = 0;

  const int32 NumClientsToTick = ServerReplicateActors_PrepConnections( DeltaSeconds );

  if ( NumClientsToTick == 0 ) { return 0; } // No connections are ready this frame</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <ul>
            <li>
              <t class="code">ServerReplicateActors_PrepConnections</t>
              <t class=""> 有两个主要功能，一是确定本帧要处理的连接的数量，也就是 </t>
              <t class="code">NumClientsToTick</t>
              <t class="">；二是轮转连接处理顺序，防止有连接不被处理</t>
            </li>
          </ul>
          <p>
            <t class="">如果没有待处理的连接，则直接结束。</t>
          </p>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang">c++</div>
              <pre><code class="language-c++">  AWorldSettings* WorldSettings = World-&gt;GetWorldSettings();

  bool bCPUSaturated    = false;
  float ServerTickTime  = GEngine-&gt;GetMaxTickRate( DeltaSeconds );
  if ( ServerTickTime == 0.f )
  {
    ServerTickTime = DeltaSeconds;
  }
  else
  {
    ServerTickTime  = 1.f/ServerTickTime;
    bCPUSaturated  = DeltaSeconds &gt; 1.2f * ServerTickTime;
  }

  TArray&lt;FNetworkObjectInfo*&gt; ConsiderList;
  ConsiderList.Reserve( GetNetworkObjectList().GetActiveObjects().Num() );

  // Build the consider list (actors that are ready to replicate)
  ServerReplicateActors_BuildConsiderList( ConsiderList, ServerTickTime );

  TSet&lt;UNetConnection*&gt; ConnectionsToClose;

  FMemMark Mark( FMemStack::Get() );

  if (OnPreConsiderListUpdateOverride.IsBound())
  {
    OnPreConsiderListUpdateOverride.Execute({ DeltaSeconds, nullptr, bCPUSaturated }, Updated, ConsiderList);
  }</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <p>
            <t class="">上面这段代码功能主要是构建待同步列表，筛选掉不需要被同步的 </t>
            <t class="code">Actor</t>
          </p>
          <ul>
            <li>
              <t class="code">ServerTickTime</t>
              <t class=""> 代表服务器 Tick 的间隔，如果设置了最大 Tick 频率（</t>
              <t class="code">ServerTickRate</t>
              <t class="">），间隔就是最大 Tick 频率的倒数，用于待同步列表的构建</t>
            </li>
            <li>
              <t class="code">ServerReplicateActors_BuildConsiderList</t>
              <t class=""> 构建待同步列表，这会剔除掉睡眠的 Actor</t>
            </li>
          </ul>
          <p>
            <t class="">再确定好了要被同步的 Actor 后，开始正式的同步逻辑。首先会遍历每个客户端连接，</t>
          </p>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang">c++</div>
              <pre><code class="language-c++">  for ( int32 i=0; i &lt; ClientConnections.Num(); i++ )
  {
    UNetConnection* Connection = ClientConnections[i];
    check(Connection);

    // net.DormancyValidate can be set to 2 to validate all dormant actors against last known state before going dormant
    if ( GNetDormancyValidate == 2 )
    {
      ...
    }</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <p>
            <t class="">首先会对休眠状态进行验证，主要是对休眠对象从睡眠状态恢复到活跃时尝试更新。</t>
          </p>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang">c++</div>
              <pre><code class="language-c++">    // if this client shouldn't be ticked this frame
    if (i &gt;= NumClientsToTick)
    {
// UE_LOG(LogNet, Log, TEXT(&quot;skipping update to %s&quot;),*Connection-&gt;GetName());
// then mark each considered actor as bPendingNetUpdate so that they will be considered again the next frame when the connection is actually ticked
      for (int32 ConsiderIdx = 0; ConsiderIdx &lt; ConsiderList.Num(); ConsiderIdx++)
      {
        AActor *Actor = ConsiderList[ConsiderIdx]-&gt;Actor;
// if the actor hasn't already been flagged by another connection,
        if (Actor != NULL &amp;&amp; !ConsiderList[ConsiderIdx]-&gt;bPendingNetUpdate)
        {
// find the channel
          UActorChannel *Channel = Connection-&gt;FindActorChannelRef(ConsiderList[ConsiderIdx]-&gt;WeakActor);
// and if the channel last update time doesn't match the last net update time for the actor
          if (Channel != NULL &amp;&amp; Channel-&gt;LastUpdateTime &lt; ConsiderList[ConsiderIdx]-&gt;LastNetUpdateTimestamp)
          {
//UE_LOG(LogNet, Log, TEXT(&quot;flagging %s for a future update&quot;),*Actor-&gt;GetName());
// flag it for a pending update
            ConsiderList[ConsiderIdx]-&gt;bPendingNetUpdate = true;
          }
        }
      }
// clear the time sensitive flag to avoid sending an extra packet to this connection
      Connection-&gt;TimeSensitive = false;
    }</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <p>
            <t class="">接着，如果一个客户端不需要在这帧被同步，并且它的 </t>
            <t class="code">Channel</t>
            <t class=""> 的上次更新时间比连接的更新时间还要早，那么会标记连接的 </t>
            <t class="code">bPendingNetUpdate</t>
            <t class=""> 为真，来让其下次被加入同步列表。</t>
          </p>
          <p>
            <t class="">接下来的代码就是处理同步的部分了。</t>
          </p>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang">c++</div>
              <pre><code class="language-c++">    else if (Connection-&gt;ViewTarget)
    {
      const int32 LocalNumSaturated = GNumSaturatedConnections;

// Make a list of viewers this connection should consider (this connection and children of this connection)
      TArray&lt;FNetViewer&gt;&amp; ConnectionViewers = WorldSettings-&gt;ReplicationViewers;

      ConnectionViewers.Reset();
      new( ConnectionViewers )FNetViewer( Connection, DeltaSeconds );
      for ( int32 ViewerIndex = 0; ViewerIndex &lt; Connection-&gt;Children.Num(); ViewerIndex++ )
      {
        if ( Connection-&gt;Children[ViewerIndex]-&gt;ViewTarget != NULL )
        {
          new( ConnectionViewers )FNetViewer( Connection-&gt;Children[ViewerIndex], DeltaSeconds );
        }
      }</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <p>
            <t class="">这段代码的逻辑是获取每个连接相关的其它观测者连接</t>
          </p>
          <ul>
            <li>
              <t class="code">ViewTarget</t>
              <t class=""> 是一个 </t>
              <t class="code">AActor</t>
              <t class=""> 指针，通常是当前的 Actor 的控制者，例如 </t>
              <t class="code">PlayerController</t>
              <t class="">，用于获取当前 </t>
              <t class="code">Actor</t>
              <t class=""> 的物理位置</t>
            </li>
            <li>
              <t class="code">Viewer</t>
              <t class="">：本质是一个</t>
              <t class="code">FNetViewer</t>
              <t class="">结构体，它包含了网络连接指针、视角、位置坐标等，用于快速判断一个物体是否在另一个物体的视野范围内，这些数据通常是关联于某个 Actor 的</t>
            </li>
            <li>
              <t class="code">new (ConnectionViewers) FNetViewer(Connection, DeltaSeconds);</t>
              <t class=""> 语法在 </t>
              <t class="code">ConnectionViewers</t>
              <t class=""> 上分配内存给一个新的 </t>
              <t class="code">FNetViewer</t>
            </li>
          </ul>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang">c++</div>
              <pre><code class="language-c++">      // send ClientAdjustment if necessary
      // we do this here so that we send a maximum of one per packet to that client; there is no value in stacking additional corrections
      if ( Connection-&gt;PlayerController )
      {
        Connection-&gt;PlayerController-&gt;SendClientAdjustment();
      }

      for ( int32 ChildIdx = 0; ChildIdx &lt; Connection-&gt;Children.Num(); ChildIdx++ )
      {
        if ( Connection-&gt;Children[ChildIdx]-&gt;PlayerController != NULL )
        {
          Connection-&gt;Children[ChildIdx]-&gt;PlayerController-&gt;SendClientAdjustment();
        }
      }</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <p>
            <t class="">遍历所有连接和子连接的 </t>
            <t class="code">PlayerController</t>
            <t class=""> 并尝试更新。</t>
          </p>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang">c++</div>
              <pre><code class="language-c++">      FMemMark RelevantActorMark(FMemStack::Get());

      const bool bProcessConsiderListIsBound = OnProcessConsiderListOverride.IsBound();

      if (bProcessConsiderListIsBound)
      {
        OnProcessConsiderListOverride.Execute( { DeltaSeconds, Connection, bCPUSaturated }, Updated, ConsiderList );
      }</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <ul>
            <li>
              <t class="code">FMemMark</t>
              <t class=""> 是内存栈的管理标记工具，它通过移动栈顶指针来分配内存，并可以快速释放。具体来说，它会记录当前的栈顶指针，调用 </t>
              <t class="code">Pop</t>
              <t class=""> 时，会将栈顶设置回开始记录的栈顶，来实现快速“释放”内存的效果。</t>
            </li>
            <li>
              <t class="code">OnProcessConsiderListOverride</t>
              <t class=""> 是自定义同步逻辑相关的事件，可以允许开发者自定义 </t>
              <t class="code">ConsiderList</t>
            </li>
          </ul>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang">c++</div>
              <pre><code class="language-c++">      if (!bProcessConsiderListIsBound)
      {
        FActorPriority* PriorityList = NULL;
        FActorPriority** PriorityActors = NULL;

        // Get a sorted list of actors for this connection
        const int32 FinalSortedCount = ServerReplicateActors_PrioritizeActors(Connection, ConnectionViewers, ConsiderList, bCPUSaturated, PriorityList, PriorityActors);</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <p>
            <t class="">这里执行的是默认的同步逻辑。首先引擎会为这个连接生成一个排序的 Actors 列表，这个列表的顺序是按照 Actor 的优先级排序的。</t>
          </p>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang">c++</div>
              <pre><code class="language-c++">        // Process the sorted list of actors for this connection
        TInterval&lt;int32&gt; ActorsIndexRange(0, FinalSortedCount);
        const int32 LastProcessedActor = ServerReplicateActors_ProcessPrioritizedActorsRange(Connection, ConnectionViewers, PriorityActors, ActorsIndexRange, Updated);

        ServerReplicateActors_MarkRelevantActors(Connection, ConnectionViewers, LastProcessedActor, FinalSortedCount, PriorityActors);
      }</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <p>
            <t class="">接着处理高优先级的 Actor</t>
          </p>
          <ul>
            <li>
              <t class="code">ServerReplicateActors_ProcessPrioritizedActorsRange</t>
              <t class=""> 会处理高优先级的 Actors 并返回没有处理完的 Actors 的数量</t>
            </li>
            <li>
              <t class="code">ServerReplicateActors_MarkRelevantActors</t>
              <t class=""> 会利用剩下的 Actor 数量，将相关的 Actor 标记为相关，并留到下帧优先处理</t>
            </li>
          </ul>
          <hr class="divider_block">
          <p>
            <t class="code">ServerReplicateActors_ProcessPrioritizedActorsRange</t>
            <t class=""> 会遍历 </t>
            <t class="code">ActorsIndexRange</t>
            <t class=""> 内的 </t>
            <t class="code">PriorityActors</t>
            <t class="">，然后每个元素的 </t>
            <t class="code">Channel</t>
            <t class=""> 和其 </t>
            <t class="code">Actor</t>
            <t class="">，并判断其它观测者与当前连接的“最近相关性”，具体条件有两个：</t>
          </p>
          <ul>
            <li>
              <t class="">在每 </t>
              <t class="code">1.0 + 0.5R</t>
              <t class=""> 秒内可见的 </t>
              <t class="code">Actor</t>
            </li>
            <li>
              <t class="">使用 </t>
              <t class="code">IsActorRelevantToConnection</t>
              <t class=""> 函数的返回结果</t>
            </li>
          </ul>
          <p>
            <t class="">经过一系列复杂的相关性判断，最终函数会获取或创建当前连接到相关的 Actor 的 Channel，并通过 </t>
            <t class="code">UNetChannel::ReplicateActor()</t>
            <t class=""> 来执行对 Actor 的复制。</t>
          </p>
          <hr class="divider_block">
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang">c++</div>
              <pre><code class="language-c++">      RelevantActorMark.Pop();
      ConnectionViewers.Reset();
      Connection-&gt;LastProcessedFrame = ReplicationFrame;
      const bool bWasSaturated = GNumSaturatedConnections &gt; LocalNumSaturated;
      Connection-&gt;TrackReplicationForAnalytics(bWasSaturated);
    }</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <p>
            <t class="">接着，上面的代码进行清除和收尾工作，包括释放临时高优先级内存、清空 </t>
            <t class="code">ConnectionViewers</t>
            <t class="">、更新 </t>
            <t class="code">LastProcessedFrame</t>
            <t class=""> 到当前帧、进行连接饱和测试（如果处理后包和数增加，说明在这帧出现了带宽瓶颈）。</t>
          </p>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang">c++</div>
              <pre><code class="language-c++">    if (Connection-&gt;GetPendingCloseDueToReplicationFailure())
    {
      ConnectionsToClose.Add(Connection);
    }
  }</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <p>
            <t class="">检查连接是否因为复制行为需要被关闭。</t>
          </p>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang">c++</div>
              <pre><code class="language-c++">  if (OnPostConsiderListUpdateOverride.IsBound())
  {
    OnPostConsiderListUpdateOverride.ExecuteIfBound( { DeltaSeconds, nullptr, bCPUSaturated }, Updated, ConsiderList );
  }</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <p>
            <t class="">广播后处理列表的自定义行为事件 </t>
            <t class="code">OnPostConsiderListUpdateOverride</t>
            <t class="">。</t>
          </p>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang">c++</div>
              <pre><code class="language-c++">  // shuffle the list of connections if not all connections were ticked
  if (NumClientsToTick &lt; ClientConnections.Num())
  {
    int32 NumConnectionsToMove = NumClientsToTick;
    while (NumConnectionsToMove &gt; 0)
    {
      // move all the ticked connections to the end of the list so that the other connections are considered first for the next frame
      UNetConnection *Connection = ClientConnections[0];
      ClientConnections.RemoveAt(0,1);
      ClientConnections.Add(Connection);
      NumConnectionsToMove--;
    }
  }
  Mark.Pop();</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <p>
            <t class="">这段代码的作用是轮转 </t>
            <t class="code">ClientConnections</t>
            <t class=""> 列表，</t>
            <t class="code">ClientConnections</t>
            <t class=""> 前面被处理了的连接轮转到最后，下帧优先处理没有轮到的连接。</t>
          </p>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang">c++</div>
              <pre><code class="language-c++">#if NET_DEBUG_RELEVANT_ACTORS
  //...debug
#endif // NET_DEBUG_RELEVANT_ACTORS

  for (UNetConnection* ConnectionToClose : ConnectionsToClose)
  {
    ConnectionToClose-&gt;Close();
  }

  return Updated;
#else
  return 0;
#endif // WITH_SERVER_CODE
}</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <p>
            <t class="">最后，引擎会关闭上面收集的需要关闭的连接。</t>
          </p>
          <hr class="divider_block">
          <p>
            <t class="">回到 </t>
            <t class="code">UNetDriver::TickFlush()</t>
            <t class="">，接下来的代码跟连接的更新有关。</t>
          </p>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang">c++</div>
              <pre><code class="language-c++">  // Reset queued bunch amortization timer
  ProcessQueuedBunchesCurrentFrameMilliseconds = 0.0f;

  // Poll all sockets.
  if( ServerConnection )
  {
    // Queue client voice packets in the server's voice channel
    ProcessLocalClientPackets();
    ServerConnection-&gt;Tick(DeltaSeconds);
  }
  else
  {
    // Queue up any voice packets the server has locally
    ProcessLocalServerPackets();
  }
  {
    QUICK_SCOPE_CYCLE_COUNTER(STAT_NetDriver_TickClientConnections)

    for (UNetConnection* Connection : ClientConnections)
    {
      Connection-&gt;Tick(DeltaSeconds);
    }
  }</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <p>
            <t class="">这部分主要处理本地的语音包。同时不管是服务端还是服务器，都会执行每个 </t>
            <t class="code">UNetConnection</t>
            <t class=""> 的 </t>
            <t class="code">Tick</t>
            <t class=""> 函数，下文会具体介绍。</t>
          </p>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang">c++</div>
              <pre><code class="language-c++">  if (ConnectionlessHandler.IsValid())
  {
    ConnectionlessHandler-&gt;Tick(DeltaSeconds);

    FlushHandler();
  }</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <p>
            <t class="">这段代码强制发送所有 </t>
            <t class="code">ConnectionlessHandler</t>
            <t class=""> 里的包。</t>
          </p>
          <ul>
            <li>
              <t class="code">ConnectionlessHandler</t>
              <t class=""> 是一个 </t>
              <t class="code">TUniquePtr&lt;PacketHandler&gt;</t>
              <t class="">，在 </t>
              <t class="code">NetDriver::InitConnectionlessHandler()</t>
              <t class=""> 被初始化，其 </t>
              <t class="code">Tick</t>
              <t class=""> 函数会安全地发送其队列里的包</t>
            </li>
            <li>
              <t class="code">FlushHandler</t>
              <t class=""> 会强制发送所有缓存的无建立连接的包</t>
            </li>
          </ul>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang">c++</div>
              <pre><code class="language-c++">  //... debug
  //... Iris
  UpdateNetworkStats();
  // Send the current values of metrics to all of the metrics listeners.
  GetMetrics()-&gt;ProcessListeners();</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <ul>
            <li>
              <t class="code">UpdateNetworkStats()</t>
              <t class=""> 主要作用是更新基础统计，如带宽利用率、丢包率等</t>
            </li>
            <li>
              <t class="code">GetMetrics()</t>
              <t class=""> 会返回 </t>
              <t class="code">UNetworkMetricsDatabase</t>
              <t class=""> 的智能指针，这个类管理着所有网络指标监听器（监听者模式），指标变化时会调用监听器，用于执行可视化、性能检测等行为，同时允许开发者使用；在 </t>
              <t class="code">UNetworkMetricsDatabase.h</t>
              <t class=""> 可以看到详细的文档注释（包含使用案例）</t>
            </li>
          </ul>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang">c++</div>
              <pre><code class="language-c++">  // Update the lag state
  UpdateNetworkLagState();
}</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <p>
            <t class="">最后，函数会更新延迟状态机。这里不深入介绍。</t>
          </p>
          <hr class="divider_block">
          <h3 id="heading3_8">
            <t class="code">UNetConnection::Tick</t>
          </h3>
          <p>
            <t class="code">UNetConnection::Tick</t>
            <t class=""> 的逻辑十分长和复杂，这里不贴其代码，而是系统性地介绍其功能，并列举部分代码。</t>
          </p>
          <p>
            <t class="">首先，在最开始，为了避免过于频繁地更新网络，导致带宽过载，引擎可能会直接跳过这帧这个连接的 Tick：</t>
          </p>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang">c++</div>
              <pre><code class="language-c++">if (!IsInternalAck() &amp;&amp; MaxNetTickRateFloat &lt; EngineTickRate &amp;&amp; DesiredTickRate &gt; 0.0f)
{
    const float MinNetFrameTime = 1.0f/DesiredTickRate;
    if (FrameTime &lt; MinNetFrameTime)
    {
      return;
    }
}</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <p>
            <t class="">具体逻辑就是当前帧时间小于设定的最小帧时间，则跳过这次 Tick。</t>
          </p>
          <p>
            <t class="">接着，处理内部 ACK 模式。内部 ACK 模式是在本地模拟远程发包收包，其发生在回放模式、本地游戏等场景。内部 ACK 模式下，不需要对数据进行网络序列化和反序列化，也可以减少回放时的延迟。</t>
          </p>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang">c++</div>
              <pre><code class="language-c++">if (IsInternalAck())
{
  ...
}</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <p>
            <t class="">接着，引擎会更新网络统计，包括带宽计算、更新进出的丢包率等。</t>
          </p>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang">c++</div>
              <pre><code class="language-c++">if ( CurrentRealtimeSeconds - StatUpdateTime &gt; StatPeriod )
{
  ...
  // Add TotalPacketsLost to total since InTotalPackets only counts ACK packets
  InPacketsLossPercentage.UpdateLoss(InPacketsLost, InTotalPackets + InTotalPacketsLost, StatPeriodCount);
  // Using OutTotalNotifiedPackets so we do not count packets that are still in transit.
  OutPacketsLossPercentage.UpdateLoss(OutPacketsLost, OutTotalNotifiedPackets, StatPeriodCount);
  ...
}</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <p>
            <t class="">然后会进行连接异常处理，连接异常会在上面的代码中被标记。</t>
          </p>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang">c++</div>
              <pre><code class="language-c++">if (bConnectionPendingCloseDueToSocketSendFailure)
{
    Close(ENetCloseResult::SocketSendFailure);
    bConnectionPendingCloseDueToSocketSendFailure = false;
    // early out
    return;
}
</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <p>
            <t class="">接着会进行超时检测。</t>
          </p>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang">c++</div>
              <pre><code class="language-c++">const float Timeout = GetTimeoutValue();

const bool bReceiveTimedOut = (CurrentRealtimeSeconds - LastReceiveRealtime) &gt; Timeout;
const bool bGracefulCloseTimedOut = (GetConnectionState() == USOCK_Closing) &amp;&amp; (DriverElapsedTime &gt; bGracefulCloseTimedOut);

if (bReceiveTimedOut || bGracefulCloseTimedOut)
{
  ...
}</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <p>
            <t class="">超时分为数据接收超时，和优雅关闭超时。</t>
          </p>
          <ul>
            <li>
              <t class="">数据接收超时（</t>
              <t class="code">bReceiveTimedOut</t>
              <t class="">）的触发条件是当前时间与最后一次收到有效数据包的时间差超过阈值 </t>
              <t class="code">Timeout</t>
              <t class="">，除了会输出日志外，还会关闭连接和尝试自动重连</t>
            </li>
            <li>
              <t class="">优雅关闭超时（</t>
              <t class="code">bGracefulCloseTimedOut</t>
              <t class="">）的触发条件是当前连接处于关闭流程中（</t>
              <t class="code">USOCK_Closing</t>
              <t class="">）并且超过了优雅超时时限（</t>
              <t class="code">bGracefulCloseTimedOut</t>
              <t class="">）。这是由正常的关闭流程，不立刻关闭时是为了等待未完成的可靠数据传输等任务完成；如果优雅关闭超时了，则会强制关闭</t>
            </li>
          </ul>
          <p>
            <t class="">不管是哪种超时，都会触发 </t>
            <t class="code">UNetConnection::HandleConnectionTimeout()</t>
            <t class=""> 函数，这个函数的功能是广播错误，并关闭当前所属连接。</t>
          </p>
          <p>
            <t class="">接着会更新 Channels：</t>
          </p>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang">c++</div>
              <pre><code class="language-c++">if (CVarTickAllOpenChannels.GetValueOnAnyThread() == 0) {
  for( int32 i=ChannelsToTick.Num()-1; i&gt;=0; i-- ) {
    ChannelsToTick[i]-&gt;Tick();
    if (ChannelsToTick[i]-&gt;CanStopTicking())
      ChannelsToTick.RemoveAt(i);
  }
}
else {
  for (int32 i = OpenChannels.Num() - 1; i &gt;= 0; i--) {
    if (OpenChannels[i]) OpenChannels[i]-&gt;Tick();
    else UE_LOG(LogNet, Warning, TEXT(&quot;UNetConnection::Tick: null channel in OpenChannels array. %s&quot;), *Describe());
  }
}</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <ul>
            <li>
              <t class="code">CVarTickAllOpenChannels</t>
              <t class=""> 配置是否 Tick 所有 Channels</t>
            </li>
          </ul>
          <p>
            <t class="">因为在大型多人游戏中，Channels 的数量往往由很多（上百），因此选择性地 Tick 需要的 Channels 对于性能由很大帮助。</t>
          </p>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang">c++</div>
              <pre><code class="language-c++">for ( auto ProcessingActorMapIter = KeepProcessingActorChannelBunchesMap.CreateIterator(); ProcessingActorMapIter; ++ProcessingActorMapIter ) {
  ...
}</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <p>
            <t class="">接着，引擎会处理要被关闭的 Actor 的 Channels 的残留数据。</t>
          </p>
          <ul>
            <li>
              <t class="code">KeepProcessingActorChannelBunchesMap</t>
              <t class=""> 是想要被完全关闭的 Channels 的表，这些 Channel 虽然被请求了完全关闭，但是还有数据未处理完成，因此需要在这里继续处理，直到完成后才关闭</t>
            </li>
          </ul>
          <p>
            <t class="">这些残留数据包括未 ACK 的已发送的可靠数据、跨帧的 Partial Bunches、延迟处理的同步属性等。</t>
          </p>
          <p>
            <t class="">然后，引擎会进行网络冲刷，发送数据：</t>
          </p>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang">c++</div>
              <pre><code class="language-c++">  if ( TimeSensitive || (Driver-&gt;GetElapsedTime() - LastSendTime) &gt; Driver-&gt;KeepAliveTime)
  {
    bool bHandlerHandshakeComplete = !Handler.IsValid() || Handler-&gt;IsFullyInitialized();

    // Delay any packet sends on the server, until we've verified that a packet has been received from the client.
    if (bHandlerHandshakeComplete &amp;&amp; HasReceivedClientPacket())
    {
      FlushNet();
    }
  }</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <p>
            <t class="code">FlushNet</t>
            <t class=""> 会调用底层的 </t>
            <t class="code">LowLevelSend</t>
            <t class=""> 来发送数据。</t>
          </p>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang">c++</div>
              <pre><code class="language-c++">// Resend any queued up raw packets (these come from the reliability handler)
BufferedPacket* ResendPacket = Handler-&gt;GetQueuedRawPacket();

if (ResendPacket &amp;&amp; Driver-&gt;IsNetResourceValid())
{
  Handler-&gt;SetRawSend(true);

  while (ResendPacket != nullptr)
  {
    LowLevelSend(ResendPacket-&gt;Data, ResendPacket-&gt;CountBits, ResendPacket-&gt;Traits);
    ResendPacket = Handler-&gt;GetQueuedRawPacket();
  }

  Handler-&gt;SetRawSend(false);
}
...</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <p>
            <t class="">接近结束的位置，函数会尝试重发数据。它会获取重发数据队列并在 while 循环中逐包发送。</t>
          </p>
          <h2 id="heading2_7">
            <t class="code">PostTickFlush</t>
          </h2>
          <p>
            <t class="code">PostTickFlush</t>
            <t class=""> 主要负责清理工作，包括清理语音包以及销毁 </t>
            <t class="code">NetDriver</t>
            <t class=""> 本身（如果 </t>
            <t class="code">NetDriver</t>
            <t class=""> 待销毁）。</t>
          </p>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang">c++</div>
              <pre><code class="language-c++">void UNetDriver::PostTickFlush()
{
#if UE_WITH_IRIS
  ...
#endif // UE_WITH_IRIS

  if (World &amp;&amp; !bSkipClearVoicePackets)
  {
    UOnlineEngineInterface::Get()-&gt;ClearVoicePackets(World);
  }</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <p>
            <t class="">清理语音包（上）。</t>
          </p>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang">c++</div>
              <pre><code class="language-c++">  if (bPendingDestruction)
  {
    if (World)
    {
      GEngine-&gt;DestroyNamedNetDriver(World, NetDriverName);
    }
    else
    {
      UE_LOG(LogNet, Error, TEXT(&quot;NetDriver %s pending destruction without valid world.&quot;), *NetDriverName.ToString());
    }
    bPendingDestruction = false;
  }
}</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <p>
            <t class="">检查和销毁 </t>
            <t class="code">NetDriver</t>
            <t class="">（上）。</t>
          </p>
          <h2 id="heading2_8">
            <t class="">小结</t>
          </h2>
          <p>
            <t class="">至此，网络系统在 Tick 阶段的通用流程已经全部完成。之所以说是通用逻辑，是因为 </t>
            <t class="code">UIpNetDriver</t>
            <t class=""> 等其它 </t>
            <t class="code">UNetDriver</t>
            <t class=""> 派生类共用了父类的行为同时实现了自己的行为，下文会简单介绍 </t>
            <t class="code">IpNetDriver</t>
            <t class=""> 以及它是如何处理握手的。</t>
          </p>
          <h1 id="heading1_3" index-text="IV">
            <t class="">握手</t>
          </h1>
          <p>
            <t class="">我们在回顾一下第一章中介绍过的握手的流程。</t>
          </p>
          <ul>
            <li>
              <t class="">客户端的 </t>
              <t class="code">UPendingNetGame::SendInitialJoin</t>
              <t class=""> 发送 </t>
              <t class="code">NMT_Hello</t>
            </li>
            <li>
              <t class="">服务器的 </t>
              <t class="code">UWorld::NotifyControlMessage</t>
              <t class=""> 接收 </t>
              <t class="code">NMT_Hello</t>
              <t class="">，并发送 </t>
              <t class="code">NMT_Challenge</t>
            </li>
            <li>
              <t class="">客户端的 </t>
              <t class="code">UPendingNetGame::NotifyControlMessage</t>
              <t class=""> 接收 </t>
              <t class="code">NMT_Challenge</t>
              <t class=""> 并在 </t>
              <t class="code">NMT_Login</t>
              <t class=""> 中发回数据</t>
            </li>
            <li>
              <t class="">服务器的 </t>
              <t class="code">UWorld::NotifyControlMessage</t>
              <t class=""> 接收 </t>
              <t class="code">NMT_Login</t>
              <t class="">，验证质询数据（challenge data），并调用 </t>
              <t class="code">AGameModeBase::PreLogin</t>
            </li>
            <li>
              <t class="">如果 </t>
              <t class="code">PreLogin</t>
              <t class=""> 并没有报任何错误，服务器会调用 </t>
              <t class="code">UWorld::WelcomePlayer</t>
              <t class="">，这个函数会调用 </t>
              <t class="code">AGameModeBase::GameWelcomePlayer</t>
              <t class=""> 并发送含有地图信息的 </t>
              <t class="code">NMT_Welcome</t>
            </li>
            <li>
              <t class="">客户端的 </t>
              <t class="code">UPendingNetGame::NotifyControlMessage</t>
              <t class=""> 接收 </t>
              <t class="code">NMT_Welcome</t>
              <t class="">，并读取地图信息（以便于后续加载），然后发送 </t>
              <t class="code">NMT_NetSpeed</t>
              <t class=""> 信息，这里包含了客户端配置了的网络速度（Net Speed）</t>
            </li>
            <li>
              <t class="">服务器的 </t>
              <t class="code">UWorld::NotifyControlMessage</t>
              <t class=""> 接收 </t>
              <t class="code">NMT_NetSpeed</t>
              <t class="">，然后调整到正确的网络速度</t>
            </li>
          </ul>
          <p>
            <t class="">在本章中，下文会具体介绍一下这个流程。在描述流程之前，首先介绍一下这部分相关的一些概念。</t>
          </p>
          <ul>
            <li>
              <t class="">一个 URL 是 </t>
              <t class="code">FURL</t>
              <t class=""> 类型，它携带了网络协议、地图路径等信息</t>
            </li>
            <li>
              <t class="">在客户端主动切换关卡时（</t>
              <t class="code">ClientTravel</t>
              <t class=""> 或 </t>
              <t class="code">OpenLevel</t>
              <t class="">），会重新建立连接</t>
            </li>
            <li>
              <t class="">在服务器主导的关卡切换时，不需要重新建立连接</t>
            </li>
          </ul>
          <p>
            <t class="code">GameplayStatics::OpenLevel()</t>
            <t class=""> 会调用 </t>
            <t class="code">UEngine::SetClientTravel</t>
            <t class="">，设置世界上下文的 </t>
            <t class="code">Context.TravelURL</t>
            <t class=""> 变量为将要加入的关卡的 URL：</t>
          </p>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang">c++</div>
              <pre><code class="language-c++">void UEngine::SetClientTravel( UWorld *InWorld, const TCHAR* NextURL, ETravelType InTravelType )
{
    FWorldContext &amp;Context = GetWorldContextFromWorldChecked(InWorld);
    Context.TravelURL    = NextURL;
    Context.TravelType   = InTravelType;
    ...
}
</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <p>
            <t class="">接着，在 </t>
            <t class="code">UGameEngine::Tick()</t>
            <t class=""> 中触发的 </t>
            <t class="code">UGameEngine::TickWorldTravel()</t>
            <t class=""> 中会调用 </t>
            <t class="code">UEngine::Browse()</t>
            <t class=""> 函数，如上文所说的，它会创建并管理一个 </t>
            <t class="code">UPendingNetGame</t>
            <t class=""> 实例，这是客户端与服务器握手的重要对象。</t>
          </p>
          <p>
            <t class="code">UEngine::Browse()</t>
            <t class=""> 会在这些地方被调用</t>
          </p>
          <ul>
            <li>
              <t class="code">UGameInstance::StartGameInstance()</t>
              <t class="">：这个函数会使用游戏默认 URL 进行 </t>
              <t class="code">Browse</t>
            </li>
            <li>
              <t class="code">UEngine::TickWorldTravel()</t>
              <t class="">：这个函数会获取传入的世界上下文（</t>
              <t class="code">FWorldContext</t>
              <t class="">）的最新的一个 URL 进行 </t>
              <t class="code">Browse</t>
              <t class="">，如果失败，会尝试使用默认的 URL，也就是下面这条的函数</t>
            </li>
            <li>
              <t class="code">UEngine::BrowseToDefaultMap()</t>
              <t class="">：这个函数会在 </t>
              <t class="code">UEngine::TickWorldTravel()</t>
              <t class=""> 被调用，试图加载默认地图</t>
            </li>
          </ul>
          <p>
            <t class="code">UPendingNetGame</t>
            <t class=""> 需要传入一个 URL 进行初始化。下面是 </t>
            <t class="code">Browse()</t>
            <t class=""> 函数初始化 </t>
            <t class="code">UPendingGame</t>
            <t class=""> 的代码。</t>
          </p>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang">c++</div>
              <pre><code class="language-c++">WorldContext.PendingNetGame = NewObject&lt;UPendingNetGame&gt;();
WorldContext.PendingNetGame-&gt;Initialize(URL); //-V595
WorldContext.PendingNetGame-&gt;InitNetDriver(); //-V595
</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <p>
            <t class="">在初始化 PendingNetGame 的过程中，会尝试初始化 NetDriver，客户端的 NetDriver 就是从此创建的。</t>
            <t class="code">InitNetDriver()</t>
            <t class=""> 会尝试调用 </t>
            <t class="code">GEngine-&gt;CreateNamedNetDriver()</t>
            <t class=""> 来创建 NetDriver，这里不深入介绍。</t>
          </p>
          <p>
            <t class="">接着，在 </t>
            <t class="code">InitNetDriver()</t>
            <t class=""> 中，</t>
            <t class="code">NetDriver-&gt;InitConnect()</t>
            <t class=""> 后会尝试开始握手，调用 </t>
            <t class="code">UPendingNetGame::BeginHandshake()</t>
            <t class=""> 函数：</t>
          </p>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang">c++</div>
              <pre><code class="language-c++">// PendingNetGame.cpp
if( NetDriver-&gt;InitConnect( this, URL, ConnectionError ) )
{
  FNetDelegates::OnPendingNetGameConnectionCreated.Broadcast(this);

  ULocalPlayer* LocalPlayer = GEngine-&gt;GetFirstGamePlayer(this);
  if (LocalPlayer)
  {
    LocalPlayer-&gt;PreBeginHandshake(ULocalPlayer::FOnPreBeginHandshakeCompleteDelegate::CreateWeakLambda(this,
      [this]()
      {
        BeginHandshake();
      }));
  }
  else
  {
    BeginHandshake();
  }
}
...</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <p>
            <t class="">接着，正如 UE 注释文档中的流程所说，客户端首先会在 </t>
            <t class="code">SendInitialJoin</t>
            <t class=""> 发送 </t>
            <t class="code">NMT_Hello</t>
            <t class="">，这件事就发生在 </t>
            <t class="code">BeginHandshake()</t>
            <t class=""> 中。</t>
          </p>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang">c++</div>
              <pre><code class="language-c++">void UPendingNetGame::BeginHandshake()
{
  // Kick off the connection handshake
  UNetConnection* ServerConn = NetDriver-&gt;ServerConnection;
  if (ServerConn-&gt;Handler.IsValid()) { ... }
  else
  {
    SendInitialJoin();
  }
}</code></pre>
            </div>
            <div class="caption"></div>
          </div>
          <p>
            <t class="">后面的流程发生在在客户端的 </t>
            <t class="code">UPendingNetGame::NotifyControlMessage</t>
            <t class=""> 和服务器的 </t>
            <t class="code">UWorld::NotifyControlMessage</t>
            <t class=""> 中。与上面的流程基本一致了，这里不多赘述。需要提及的一点是这两个函数的调用时机：</t>
          </p>
          <ul>
            <li>
              <t class="code">UPendingNetGame::NotifyControlMessage</t>
              <t class=""> 会在 </t>
              <t class="code">UControlChannel::ReceivedBunch</t>
              <t class=""> 中被调用，经过层层转发，最顶层的触发时机为 </t>
              <t class="code">IpNetDriver</t>
              <t class=""> 的 </t>
              <t class="code">TickDispatch</t>
            </li>
            <li>
              <t class="code">UWorld::NotifyControlMessage</t>
              <t class=""> 经过层层转发，在顶层也是在 </t>
              <t class="code">UWorld::OnTickDispatch</t>
              <t class=""> 中被触发</t>
            </li>
          </ul>
          <h2 id="heading2_9">
            <t class="">小结</t>
          </h2>
          <p>
            <t class="">UE 的握手由客户端在载入关卡时被设定在成员变量中，并在 </t>
            <t class="code">TickWorldTravel</t>
            <t class=""> 中创建 </t>
            <t class="code">UPendingNetGame</t>
            <t class=""> 并开始握手流程。握手流程主要发生在客户端的 </t>
            <t class="code">UPendingNetGame::NotifyControlMessage</t>
            <t class=""> 和服务器的 </t>
            <t class="code">UWorld::NotifyControlMessage</t>
            <t class=""> 中，两者通过传递各项控制信息与地图信息，完成连接的建立。</t>
          </p>
        </div>
      </div>
      <div class="sidebar_wrapper_right sidebar_wrapper">
        <div class="catalogue">
          <ul>
            <li class="h1"><a href="#heading1_0">
                <t class="">UE 网络同步系统</t>
              </a></li>
            <li class="h2"><a href="#heading2_0">
                <t class="code">NetDriver</t>
                <t class="">, </t>
                <t class="code">NetConnections</t>
                <t class=""> 和 </t>
                <t class="code">Channels</t>
              </a></li>
            <li class="h2"><a href="#heading2_0">
                <t class="code">Game Net Drivers</t>
                <t class="">, </t>
                <t class="code">Net Connections</t>
                <t class="">, 和 </t>
                <t class="code">Channels</t>
              </a></li>
            <li class="h2"><a href="#heading2_0">
                <t class="">初始化连接 / 握手流程（Initiating Connections / Handshaking Flow）</t>
              </a></li>
            <li class="h3"><a href="#heading3_0">
                <t class="">开始设置与握手（Startup and Handshaking）</t>
              </a></li>
            <li class="h3"><a href="#heading3_1">
                <t class="code">UWorld / UPendingNetGame / AGameModeBase Startup and Handshaking</t>
              </a></li>
            <li class="h3"><a href="#heading3_2">
                <t class="">重新建立丢失的连接（Reestablishing Lost Connections）</t>
              </a></li>
            <li class="h2"><a href="#heading2_3">
                <t class="">数据传输（Data Transmission）</t>
              </a></li>
            <li class="h3"><a href="#heading3_3">
                <t class="">可靠性和重新传输（Reliability and Retransmission）</t>
              </a></li>
            <li class="h3"><a href="#heading3_4">
                <t class="">接收侧检测丢包（Detecting Incoming Dropped Packets）</t>
              </a></li>
            <li class="h3"><a href="#heading3_5">
                <t class="">发出侧检测丢包（Detecting Outgoing Dropped Packets）</t>
              </a></li>
            <li class="h3"><a href="#heading3_6">
                <t class="">重新发送丢失数据（Resending Missing Data）</t>
              </a></li>
            <li class="h1"><a href="#heading1_1">
                <t class="">重要概念</t>
              </a></li>
            <li class="h1"><a href="#heading1_2">
                <t class="">源代码梳理 - Tick 阶段</t>
              </a></li>
            <li class="h2"><a href="#heading2_7">
                <t class="code">TickDispatch</t>
              </a></li>
            <li class="h2"><a href="#heading2_7">
                <t class="code">PostTickDispatch</t>
              </a></li>
            <li class="h2"><a href="#heading2_7">
                <t class="code">TickFlush</t>
              </a></li>
            <li class="h3"><a href="#heading3_7">
                <t class="code">ServerReplicateActors()</t>
              </a></li>
            <li class="h3"><a href="#heading3_8">
                <t class="code">UNetConnection::Tick</t>
              </a></li>
            <li class="h2"><a href="#heading2_9">
                <t class="code">PostTickFlush</t>
              </a></li>
            <li class="h2"><a href="#heading2_9">
                <t class="">小结</t>
              </a></li>
            <li class="h1"><a href="#heading1_3">
                <t class="">握手</t>
              </a></li>
            <li class="h2"><a href="#heading2_9">
                <t class="">小结</t>
              </a></li>
          </ul>
        </div>
      </div>
    </div>
  </body>
</html>
